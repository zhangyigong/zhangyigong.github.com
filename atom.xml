<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[张一弓的Blog]]></title>
  <subtitle><![CDATA[眯着眼睛安静思考世界的攻城狮]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhangyigong.github.com/"/>
  <updated>2015-04-16T09:44:10.930Z</updated>
  <id>http://zhangyigong.github.com/</id>
  
  <author>
    <name><![CDATA[Lionel]]></name>
    <email><![CDATA[zhang_1g@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux 软件包管理（三）源码包管理]]></title>
    <link href="http://zhangyigong.github.com/2015/03/08/linux-software-management-3/"/>
    <id>http://zhangyigong.github.com/2015/03/08/linux-software-management-3/</id>
    <published>2015-03-08T15:41:55.000Z</published>
    <updated>2015-03-09T02:38:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="源码包与RPM_包的区别">源码包与RPM 包的区别</h2>
<p><strong>安装之前的区别</strong></p>
<p>安装之前的区别主要体现为概念上的区别：源码包是开源的，安装时配置更加自由，安装完成后效率更高，但是它安装更慢，安装过程更容易报错；而RPM 包只是编译好的二进制包，但是它安装速度快，出错也容易解决，只有依赖性的问题。</p>
<p><strong>安装之后的区别</strong></p>
<p>安装之后，两个最直接的区别就是安装位置的区别。我们知道RPM 包在安装时各个文件的路径已经确定好了，不用人为进行修改，而源码包在安装时则需要人为指定安装路径。由于安装位置的区别，使得源码包和RPM 包在后续的管理工程中也会有一些区别。</p>
<p>RPM 包的默认安装位置大致如下：</p>
<blockquote>
<p>/etc/              配置文件安装目录<br>/usr/bin/          可执行的命令安装目录<br>/usr/lib/          程序所使用的函数库保存位置<br>/usr/share/doc/   基本的软件使用手册保存位置<br>/usr/share/man/   帮助文件保存位置 </p>
</blockquote>
<a id="more"></a>

<p>而在手工指定源码包的安装路径时，一般指定为 <code>/usr/local/软件名/</code>。</p>
<p>由于二者安装位置不同带来的影响主要包括：</p>
<p>RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是：<code>/etc/rc.d/init.d/httpd start</code>或者<code>service httpd start</code>，注意linux 中各种service 的执行文件的路径一般都在 <code>/etc/rc.d.init.d/</code>下，还有一点就是 <code>service</code> 命令是Redhat 系列Linux 的专有命令；</p>
<p>源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如 <code>/usr/local/apache2/bin/apachectl start</code></p>
<p>总的来说就是RPM 包可以使用系统的服务管理命令来管理，而源码包只能使用绝对路径来管理。</p>
<h2 id="源码包的安装过程">源码包的安装过程</h2>
<p><strong>安装准备</strong></p>
<ul>
<li>安装C 语言编译器gcc，可以使用yum 在线安装</li>
<li>以Apache 为例下载源码包<a href="http://mirror.bit.edu.cn/apache/httpd/" target="_blank" rel="external">http://mirror.bit.edu.cn/apache/httpd/</a></li>
</ul>
<p><strong>安装注意事项</strong></p>
<ul>
<li>源代码保存位置：<code>/usr/local/src/</code></li>
<li>软件安装位置：<code>/usr/local/</code></li>
<li>如何确认安装过程报错：安装过程停止并且出现error、warning或no 的提示</li>
</ul>
<p><strong>源码包安装过程</strong></p>
<p><strong>step1</strong>: 下载源码包到源码保存位置</p>
<p><strong>step2</strong>: 解压下载的源码包。使用命令 <code>tar -zxvf httpd-2.2.9.tar.gz</code> 将源码包解压缩，并执行命令 <code>du -sh httpd-2.2.9</code> 来查看解压后源码包的大小。</p>
<p><strong>step3</strong>: 进入解压缩目录。注意这一步必须进行，因为后续操作必须在压缩目录中进行。进入目录之后，需要注意两个文件，一个是 <code>INSTALL</code>，一个是 <code>README</code>，前一个是安装说明，后一个是使用说明。因此在安装一个陌生的源码包时需要首先查看 <code>INSTALL</code> 文件，里面会有详细的软件包安装步骤的说明。</p>
<p><strong>step4</strong>：./configure 软件配置与检查</p>
<ol>
<li>定义需要的功能选项。软件配置的参数（功能选项）可以执行命令 <code>./configure --help</code> 查看不同功能选项的详细信息。这里安装路径是必须定义的，可通过命令 <code>./configure --prefix=/usr/local/apache2</code> 来指定安装位置。</li>
<li>检测系统环境是否符合安装要求，比如是否安装了gcc 等。</li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile 文件，用于后续的编辑。Makefile 文件起初是不存在的，它要在执行命令 <code>./configure --prefix=/usr/local/apache2</code> 之后才会生成。</li>
<li>make 命令进行编译，比较耗时，如果在编译时报错，或者在执行 <code>./configure</code> 命令时报错，可以通过命令 <code>make clean</code> 清空产生的临时文件。</li>
<li>make install 编译安装，这一步执行后才会向指定目录下生成安装文件。</li>
<li>安装完成之后可以通过执行命令 <code>/usr/local/apache2/bin/apachect1 start</code> 来启动Apache 服务。那么为什么此处的命令不是 httpd 而是apachect1 呢？我们可以在解压的安装包目录下的 <code>INSTALL</code> 文件进行查看。</li>
</ol>
<p><strong>源码包的卸载</strong></p>
<p>源码包的卸载不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /usr/<span class="keyword">local</span>/apache2</div></pre></td></tr></table></figure>

<h2 id="脚本安装包与软件包选择">脚本安装包与软件包选择</h2>
<p>脚本安装包并不是独立的软件包类型，使用脚本安装常见的是安装源码包。脚本安装包是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。</p>
<p>脚本安装包一般是一些硬件的驱动，如果手工安装的话比较复杂，因此很多厂商会提供安装脚本。它类似于windows 下的软件安装方式，只需要执行脚本 <code>setup.sh</code> 即可。</p>
<p>使用脚本安装可以使用 Webmin 软件进行实验。Webmin 是一个基于Web 的Linux 系统管理界面。可以通过图形化的方式设置用户帐号、Apache、DNS、文件共享等服务。 </p>
<h2 id="总结">总结</h2>
<p>本篇博客主要讲述了源码包和RPM 包的区别，以及源码包的安装步骤。那么如何在安装RPM 包和安装源码包之间进行取舍呢？可以这样理解，如果安装的源码包不会对外提供服务，比如gcc，那么就可以安装rpm 包，而像Apache 这样会对外提供服务的软件包则最好使用源码包的方式进行安装。另外还简单介绍了脚本安装包的使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="源码包与RPM_包的区别">源码包与RPM 包的区别</h2>
<p><strong>安装之前的区别</strong></p>
<p>安装之前的区别主要体现为概念上的区别：源码包是开源的，安装时配置更加自由，安装完成后效率更高，但是它安装更慢，安装过程更容易报错；而RPM 包只是编译好的二进制包，但是它安装速度快，出错也容易解决，只有依赖性的问题。</p>
<p><strong>安装之后的区别</strong></p>
<p>安装之后，两个最直接的区别就是安装位置的区别。我们知道RPM 包在安装时各个文件的路径已经确定好了，不用人为进行修改，而源码包在安装时则需要人为指定安装路径。由于安装位置的区别，使得源码包和RPM 包在后续的管理工程中也会有一些区别。</p>
<p>RPM 包的默认安装位置大致如下：</p>
<blockquote>
<p>/etc/              配置文件安装目录<br>/usr/bin/          可执行的命令安装目录<br>/usr/lib/          程序所使用的函数库保存位置<br>/usr/share/doc/   基本的软件使用手册保存位置<br>/usr/share/man/   帮助文件保存位置 </p>
</blockquote>
]]>
    
    </summary>
    
      <category term="linux" scheme="http://zhangyigong.github.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 软件包管理（二）yum 命令]]></title>
    <link href="http://zhangyigong.github.com/2015/03/07/linux-software-management-2/"/>
    <id>http://zhangyigong.github.com/2015/03/07/linux-software-management-2/</id>
    <published>2015-03-07T15:30:18.000Z</published>
    <updated>2015-03-09T02:48:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="yum_在线管理概述">yum 在线管理概述</h2>
<p>通过rpm 命令手工管理软件包，最大的问题就是软件包的依赖性问题，而yum 正是为了解决这个问题而存在的，Redhat 系列的yum 是收费的，不过Centos 却是个例外，因此我们可以在Centos 环境下方便地使用yum 命令。</p>
<p>使用yum 命令只需要提供需要安装的软件包的全名，系统就会自动从服务器上下载相应的软件包，各种依赖关系也会自动处理。当没有网络的时候，我们也可以将光盘配置成yum。</p>
<h2 id="IP地址配置">IP地址配置</h2>
<p>使用网络服务器上的yum 源，需要保证安装的linux 能够访问外网，因此不仅要能够正确地配置IP 地址和子网掩码，还要正确的配置DNS 和网关。如果说使用 <code>ifconfig eth0 192.168.x.x</code> 对IP 地址进行修改，由于配置文件没有发生变化，配置只是临时生效，在重启系统或者网络服务之后会恢复到原来的IP 地址。 而且这种方式只能够配置网络的IP 和子网掩码，但是要上公网还需要配置系统的DNS 和网关。</p>
<p>在包括Centos 在内的Redhat 系列的Linux 中配置网络参数有一种简便的方法，就是使用命令 <code>setup</code>，该命令可以使用窗口进行网络参数的配置，具体如下所示：</p>
<a id="more"></a>

<p><img src="http://zhang1g.qiniudn.com/network-setup-command-1.PNG" alt="setup 命令配置网络参数"></p>
<p><img src="http://zhang1g.qiniudn.com/network-setup-command-2.PNG" alt="setup 命令配置网络参数"></p>
<p>执行 <code>setup</code> 命令之后，选择 <code>Network configuration</code> 选项，回车之后选择设备配置项进行各项网络参数的配置。</p>
<p>如果当前网络环境中没有DHCP 服务器，则按空格取消DHCP 选项中的 <code>*</code> 号，进行IP 地址的手动更改，接下来就是各项网络参数的更改，更改配置完成后保存退出。注意此时更改还没有生效，需要<strong>重新启动系统或者网络服务</strong>配置才会生效，一般来说可以执行一下命令重启网络服务。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service network restart		</div><div class="line"><span class="preprocessor">#重启网络服务</span></div></pre></td></tr></table></figure>

<p>还需要注意的另外一点是，Centos 6.3 的版本之中，网卡默认是没有启动的。因此在重启网络服务之前需要首先执行命令 <code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code>，修改配置文件中的内容，把 <code>ONBOOT=“no”</code> 改为 <code>ONBOOT=“yes”</code> 来启动网卡。如果没有 <code>setup</code> 命令，也是在这个配置文件中进行网络参数的配置。</p>
<h2 id="网络yum_源">网络yum 源</h2>
<p>网络yum 源地址保存在目录 <code>/etc/yum.repos.d/</code> 下面，该文件夹下所有以 <code>.repo</code> 为后缀的文件都是合法的yum 源。以默认的yum 源为例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vi</span> /etc/yum.repos.<span class="keyword">d</span>/CentOS-Base.repo</div></pre></td></tr></table></figure>

<p><img src="http://zhang1g.qiniudn.com/yum-source-1.PNG" alt="yum 源配置文件中的软件池地址格式"></p>
<p>其中包含了若干个软件池地址，格式如上图所示，具体的参数含义如下：</p>
<ul>
<li><strong>[base]</strong>           容器名称，一定要放在[]中</li>
<li><strong>name</strong>            容器说明，可以自己随便写</li>
<li><strong>mirrorlist</strong>      镜像站点，这个可以注释掉</li>
<li><strong>baseurl</strong>         我们的yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址</li>
<li><strong>enabled</strong>          此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效，默认是生效的</li>
<li><strong>gpgcheck</strong>      如果是1是指RPM的数字证书生效，如果是0则不生效</li>
<li><strong>gpgkey</strong>        数字证书的公钥文件保存位置。不用修改</li>
</ul>
<p>一般来说，上述配置文件已经配置好了，不需要进行修改，在网络连通的情况下直接使用yum 命令即可，这里我们只需要看懂各个配置参数的含义就可以了。</p>
<h2 id="常用_yum命令">常用 yum命令</h2>
<p><strong>查询</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yum list </div><div class="line"><span class="preprocessor">#查询服务器上所有可用软件包列表，可在任意目录下执行</span></div><div class="line"></div><div class="line">yum search 关键字	</div><div class="line"><span class="preprocessor">#搜索服务器上所有和关键字相关的包</span></div></pre></td></tr></table></figure>

<p>上述命令中的关键字一般就是包名，注意包名和包全名的区别只对rpm 手工管理生效，yum 命令只是使用包名。</p>
<p><strong>安装</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum –y <span class="operator"><span class="keyword">install</span> 包名 	</span></div><div class="line">#选项：<span class="keyword">install</span> 安装 -y 自动回答yes</div></pre></td></tr></table></figure>

<p>安装完成之后可以执行命令 <code>rpm -q 包名</code> 查询软件包是否安装完成。</p>
<p><strong>升级</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -<span class="keyword">y</span> <span class="keyword">update</span> 包名 		</div><div class="line">#选项：<span class="keyword">update</span> 升级 	-<span class="keyword">y</span> 自动回答yes</div></pre></td></tr></table></figure>

<p>升级命令需要注意的是，不要忘了在后面添加包名，否则会连同linux 内核在内的软件包一同升级，导致出现宕机。</p>
<p><strong>卸载</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -<span class="keyword">y</span> <span class="built_in">remove</span> 包名 		</div><div class="line">#选项：<span class="built_in">remove</span> 卸载	-<span class="keyword">y</span> 自动回答yes</div></pre></td></tr></table></figure>

<p>yum 卸载命令会自动处理依赖，可能会卸载系统的依赖包，导致系统宕机崩溃。所以我们一般要做到最小化安装，尽量不使用yum 卸载。</p>
<p><strong>yum 软件组管理</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">yum grouplist	</div><div class="line"><span class="preprocessor">#列出所有可用的软件组列表</span></div><div class="line">yum groupinstall 软件组名	</div><div class="line"><span class="preprocessor">#安装指定的软件组，组名可由gropulist 查出来，</span></div><div class="line"><span class="preprocessor">#注意软件包租应该是英文名称，出现空格要用引号括起来</span></div><div class="line">yum groupremove 软件组名	</div><div class="line"><span class="preprocessor">#卸载指定软件组</span></div></pre></td></tr></table></figure>

<h2 id="光盘yum源搭建">光盘yum源搭建</h2>
<p>在网络连接断开时，如果使用yum 进行软件包的安装，可以将光盘作为yum 源。光盘yum 源的搭建步骤如下：</p>
<p><strong>step1</strong>:    挂载光盘    <code>mount /dev/sr0 /mnt/cdrom</code></p>
<p><strong>step2</strong>:     让网络yum源文件失效    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</div><div class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</div><div class="line">mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak</div><div class="line">mv CentOS-Vault.repo CentOS-Vault.repo.bak</div></pre></td></tr></table></figure>

<p><strong>step3</strong>: 修改光盘yum 源文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vim</span> CentOS-Media.repo</div></pre></td></tr></table></figure>

<p>文件的内容具体如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[c6-media]</div><div class="line">name=CentOS-$releasever - Media</div><div class="line">baseurl=file:<span class="comment">///mnt/cdrom</span></div><div class="line"><span class="preprocessor">#地址为你自己的光盘挂载地址</span></div><div class="line"><span class="preprocessor"># file:///media/cdrom/</span></div><div class="line"><span class="preprocessor"># file:///media/cdrecorder/</span></div><div class="line"><span class="preprocessor">#注释这两个不存在的地址</span></div><div class="line">gpgcheck=<span class="number">1</span></div><div class="line">enabled=<span class="number">1</span></div><div class="line"><span class="preprocessor">#把enabled=0改为enabled=1，让这个yum源配置文件生效</span></div><div class="line">gpgkey=file:<span class="comment">///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span></div></pre></td></tr></table></figure>

<p>在修改yum 源文件时需要注意一下几点内容：</p>
<ol>
<li>baseurl 不再是基于http 的，需要改成光盘挂载点，此外要把多余的file 注释掉；</li>
<li>enabled 的值要修改为1；</li>
<li>配置文件的排版格式不要乱修改，否则会出错，比如说注释要写在行首。</li>
</ol>
<h2 id="总结">总结</h2>
<p>本篇博客主要讲述了使用yum 命令在线管理rpm 包的一些内容，主要包括：</p>
<ul>
<li>yum 在线管理的好处</li>
<li>Centos 如何修改网络参数以及中间需要注意的地方</li>
<li>网络yum 源所相关的配置文件路径 <code>/etc/yum.repos.d/</code> 以及文件格式</li>
<li>常用的yum 命令，包括查询、安装、升级、卸载以及软件组的管理命令</li>
<li>使用光盘搭建yum 源的步骤</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="yum_在线管理概述">yum 在线管理概述</h2>
<p>通过rpm 命令手工管理软件包，最大的问题就是软件包的依赖性问题，而yum 正是为了解决这个问题而存在的，Redhat 系列的yum 是收费的，不过Centos 却是个例外，因此我们可以在Centos 环境下方便地使用yum 命令。</p>
<p>使用yum 命令只需要提供需要安装的软件包的全名，系统就会自动从服务器上下载相应的软件包，各种依赖关系也会自动处理。当没有网络的时候，我们也可以将光盘配置成yum。</p>
<h2 id="IP地址配置">IP地址配置</h2>
<p>使用网络服务器上的yum 源，需要保证安装的linux 能够访问外网，因此不仅要能够正确地配置IP 地址和子网掩码，还要正确的配置DNS 和网关。如果说使用 <code>ifconfig eth0 192.168.x.x</code> 对IP 地址进行修改，由于配置文件没有发生变化，配置只是临时生效，在重启系统或者网络服务之后会恢复到原来的IP 地址。 而且这种方式只能够配置网络的IP 和子网掩码，但是要上公网还需要配置系统的DNS 和网关。</p>
<p>在包括Centos 在内的Redhat 系列的Linux 中配置网络参数有一种简便的方法，就是使用命令 <code>setup</code>，该命令可以使用窗口进行网络参数的配置，具体如下所示：</p>
]]>
    
    </summary>
    
      <category term="linux" scheme="http://zhangyigong.github.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 虚拟机的垃圾回收机制]]></title>
    <link href="http://zhangyigong.github.com/2015/03/05/java-jvm-gc/"/>
    <id>http://zhangyigong.github.com/2015/03/05/java-jvm-gc/</id>
    <published>2015-03-05T02:31:01.000Z</published>
    <updated>2015-04-16T09:43:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="内存回收算法">内存回收算法</h2>
<p>Java 虚拟机的内存动态分配与垃圾内存回收技术已经相当成熟，而垃圾内存回收主要是判断对象是否还存活，判断对象是否存活的算法主流有两种：<strong>引用计数算法</strong>和<strong>根搜索算法</strong>。</p>
<p><strong>引用计数法</strong></p>
<p>引用计数法是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。现代编程语言比如Lisp，Python，Ruby等的垃圾收集算法采用的就是引用计数算法。</p>
<p><strong>根搜索法</strong></p>
<p>主流的商用程序语言（Java和C#）都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。</p>
<p>这个算法的基本思路就是通过一系列的名为 <code>GC Roots</code> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain），当一个对象到 <code>GC Roots</code> 没有任何引用链相连（用图论的话来说就是从 <code>GC Roots</code> 到这个对象不可达）时，则证明此对象是不可用的。如图下图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 <code>GC Roots</code> 是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p><img src="http://zhang1g.qiniudn.com/jvm-gc-gc-roots.jpg" alt="jvm 垃圾回收机制根搜索法"></p>
<p>Java 中可以作为 <code>GC Root</code> 的对象包括以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表）中的引用的对象</li>
<li>方法区中类的静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native方法）的引用的对象</li>
</ul>
<h2 id="Java_引用分类">Java 引用分类</h2>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与 <strong>引</strong>有关。</p>
<p>在JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。</p>
<ol>
<li><p>强引用就是指在程序代码之中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2 之后，提供了SoftReference 类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2 之后，提供了WeakReference 类来实现弱引用。</p>
</li>
<li><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2 之后，提供了PhantomReference 类来实现虚引用。</p>
</li>
</ol>
<h2 id="Java_回收区域">Java 回收区域</h2>
<p>就Java而言，在内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而 有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法 结束或线程结束时，内存自然就跟随着回收了。</p>
<p>而Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<p><strong>标记-清除算法</strong></p>
<p>最基础的收集算法是 <code>标记-清除</code>（Mark-Sweep）算法，如它的名字一样，算法分为<strong>标记</strong>和<strong>清除</strong>两个阶段：</p>
<p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 </p>
<p>标记-清除算法的执行过程如下所示：</p>
<p><img src="http://zhang1g.qiniudn.com/java-gc-mark-sweep.jpg" alt="jvm 垃圾回收标记-清除算法"></p>
<p><strong>复制算法</strong></p>
<p>为了解决效率问题，一种称为 <code>复制</code>（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>
<p><img src="http://zhang1g.qiniudn.com/java-gc-copying.jpg" alt="jvm 垃圾回收复制算法"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden 空间和两块较小的Survivor 空间，每次使用Eden和其中的一块Survivor。</p>
<p>当回收时，将Eden 和Survivor 中还存活着的对象一次性地拷贝到另外一块Survivor 空间上，最后清理掉Eden 和刚才用过的Survivor 的空间。</p>
<p>HotSpot 虚拟机默认Eden 和Survivor 的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10% 的内存是会被“浪费”的。</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保</strong>（Handle Promotion）。如果另外一块Survivor 空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>
<p><strong>标记-整理算法</strong></p>
<p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种 <code>标记-整理</code>（Mark-Compact）算法，标记过程仍然与 <code>标记-清除</code> 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，<code>标记-整理</code> 算法的示意图如下所示。</p>
<p><img src="http://zhang1g.qiniudn.com/java-gc-mark-compact.jpg" alt="jvm 垃圾回收标记-整理算法"></p>
<p><strong>分代收集算法</strong></p>
<p>当前商业虚拟机的垃圾收集都采用 <code>分代收集</code>（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="内存回收算法">内存回收算法</h2>
<p>Java 虚拟机的内存动态分配与垃圾内存回收技术已经相当成熟，而垃圾内存回收主要是判断对象是否还存活，判断对象是否存活的算法主流有两种：<strong>引用计数算法</strong>和<strong>根搜索算法</st]]>
    </summary>
    
      <category term="java" scheme="http://zhangyigong.github.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 软件包管理（一）rpm 命令]]></title>
    <link href="http://zhangyigong.github.com/2015/03/04/linux-software-management-1/"/>
    <id>http://zhangyigong.github.com/2015/03/04/linux-software-management-1/</id>
    <published>2015-03-04T08:56:07.000Z</published>
    <updated>2015-03-09T02:26:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="软件包管理简介">软件包管理简介</h2>
<p>Linux 中的可以安装的软件包可以分为两类：源码包和二进制包，其中源码包绝大部分是用C 语言写的，而二进制包又叫做RPM 包，是已经编译好的安装包，也是系统默认包，这两类安装包有各自的优缺点。</p>
<p>源码包的优点是：</p>
<ol>
<li>开源，如果有足够的能力，可以修改源代码；</li>
<li>可以自由选择所需的功能；</li>
<li>软件是编译安装，所以更加适合自己的系统，比起RPM包更加稳定也效率更高；</li>
<li>卸载方便。</li>
</ol>
<p>源码包的缺点是：</p>
<ol>
<li>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误；</li>
<li>编译过程时间较长，安装比二进制安装时间长；</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决。</li>
</ol>
<a id="more"></a>

<p>RPM 包的优点是：</p>
<ol>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载；</li>
<li>安装速度比源码包安装快的多。</li>
</ol>
<p>RPM 包的缺点是：</p>
<ol>
<li>经过编译，不再可以看到源代码；</li>
<li>功能选择不如源码包灵活；</li>
<li>存在包依赖性，难以管理。</li>
</ol>
<p>RPM 包相对而言安装比较简单，因此先来介绍RPM 软件包安装的相关内容。其中RPM 包的管理分为rpm 手动管理和yum 在线管理。</p>
<h2 id="RPM_包管理-rpm_命令管理">RPM 包管理-rpm 命令管理</h2>
<p>首先需要介绍两个内容，一个是RPM 包的命名规则，另外一个是RPM 包的依赖性。</p>
<p><strong>RPM 包命名规则</strong></p>
<p>所有的RPM 包都在Linux 的安装光盘中，以Centos 为例，在光盘目录下的Packages 目录下存放了所有的RPM 包，大约有2000多个。仔细看一下，我们会发现这些包的命名都是非常相似的。以Apache 的RPM 包为例：</p>
<p><code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code></p>
<ul>
<li>httpd      软件包名</li>
<li>2.2.15    软件版本</li>
<li>15      软件发布的次数</li>
<li>el6.centos    适合的Linux平台</li>
<li>i686      适合的硬件平台</li>
<li>rpm      rpm包扩展名</li>
</ul>
<p>我们知道在linux 中是没有扩展名的，但是所有的RPM 包都必须以rpm 结尾，以方便管理员能够清晰的认识到文件的类型是RPM 安装包。另外如果在 <code>i686</code> 的位置上出现了 <code>noarch</code> 则表明在任何硬件平台上都可以安装。</p>
<p>此处我们需要特别区分的是<strong>包名</strong>和<strong>包全名</strong>，因为在执行命令时不加区分会出错。可以简单的理解为在软件包还没有安装之前使用安装包相关的命令要使用包全名，并且要先切换到未安装的软件包的目录下进行操作。而对于已经安装的软件包，在使用命令时使用包名就可以了，因为它是搜索 <code>/var/lib/rpm/</code> 中的数据库，所以在任何的路径下都可以执行。</p>
<p>比如说上面的Apache 软件包，软件包的软件包全名就是 <code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code>,而包名是第一部分 <code>httpd</code>。</p>
<p><strong>RPM 包依赖性</strong></p>
<p>上面我们已经提到，依赖性是RPM 包的缺点。典型的依赖有树形依赖、环形依赖和模块依赖。</p>
<ul>
<li>树形依赖：    a-&gt;b-&gt;c</li>
<li>环形依赖：    a-&gt;b-&gt;c-&gt;a</li>
<li>模块依赖：    安装包依赖于库文件，可在<a href="www.rpmfind.net">模块依赖查询网站</a>上查询库文件对应的RPM 包</li>
</ul>
<p>在树形依赖的例子中，安装软件包a，会提示软件包b，安装提示软件包c，依赖关系为a依赖于b依赖于c。因此安装时要按照c、b、a 的顺序安装，卸载时要按照a、b、c 的顺序卸载。</p>
<p>另外，在遇到环形依赖时，将a、b、c 用一条命令同时安装则可以解决。</p>
<p>模块依赖指的是安装包依赖于 <code>.so.数字</code> 结尾的库文件，而库文件是属于rpm 包的一部分，因此我们需要在<a href="www.rpmfind.net">模块依赖查询网站</a>上查出库文件对应的rpm 包并安装该rpm 包。</p>
<p>为了解决RPM 包的依赖性问题，就有了后来的yum 软件包管理，我们后面会提到。yum 会自动解决以上三种类型的依赖关系，而且如果不能上网的话，也可以使用光盘作为本地yum 源。不过Redhat 系列的linux，yum 的使用是收费的，还好Centos 的yum 使用是免费的。</p>
<h2 id="RPM_包管理-rpm_手动管理">RPM 包管理-rpm 手动管理</h2>
<p>在细说RPM 安装包之前，再强调一下包名和包全名的区别，一般来说，执行安装和升级命令，使用的是包全名，而查询和卸载这样的命令执行时使用的就只是包名。下面是关于使用rpm 命令管理RPM 包的一些内容。</p>
<p><strong>RPM 包的安装</strong></p>
<p><code>rpm –ivh 包全名</code></p>
<p>选项：</p>
<ul>
<li>-i（install）    安装</li>
<li>-v（verbose）    显示详细信息</li>
<li>-h（hash）       显示进度</li>
<li>—nodeps           不检测依赖性（一般不使用）</li>
</ul>
<p>注意在使用rpm 命令安装软件包时由于是从系统安装盘中安装，所以需要挂载光盘。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> /mnt/cdrom</div><div class="line">mount /dev/sr0 /mnt/cdrom</div><div class="line"><span class="keyword">cd</span> /mnt/cdrom/Packages</div><div class="line">rpm -ivh httpd-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span>.el6.centos.<span class="number">1</span>.i686.rpm</div></pre></td></tr></table></figure>

<p><strong>RPM 包的升级</strong></p>
<p><code>rpm -Uvh 包全名</code></p>
<p>选项：</p>
<ul>
<li>-U（upgrade）    升级（注意此处的U 要使用大写字母）</li>
</ul>
<p><strong>RPM 包卸载</strong></p>
<p><code>rpm -e 包名</code></p>
<p>选项：</p>
<ul>
<li>-e（erase）  卸载</li>
<li>—nodeps    不检查依赖性（一般不使用）</li>
</ul>
<p><strong>RPM 包查询是否安装</strong></p>
<p>在实际应用时，我们可能很少使用rpm 命令进行软件包的安装和升级，但是使用rpm 命令查询软件包是否安装却是非常普遍的操作。</p>
<p><code>rpm -q 包名</code>        #查询软件包是否安装</p>
<p>选项：</p>
<ul>
<li>-q  查询（query）</li>
</ul>
<p><code>rpm –qa</code>            #查询所有已经安装的RPM包</p>
<p>选项：</p>
<ul>
<li>-a  所有（all） </li>
</ul>
<p>要注意不管使用rpm 命令还是使用yum 在线安装的安装包，都可以使用上述命令进行查询。</p>
<p>以Apache 软件包为例，在命令中使用管道符 <code>rpm -qa | grep httpd</code>，可以查询Apache 包名相关的软件包。</p>
<p><strong>RPM 包查询详细信息</strong></p>
<p><code>rpm –qi 包名</code>        #查询软件包的详细信息</p>
<p>选项：</p>
<ul>
<li>-i  查询已安装的软件信息（information）</li>
<li>-p  查询未安装包信息（package），<strong>注意命令之后要加的是包全名，而不是包名</strong></li>
</ul>
<p>在使用命令 <code>rpm –qip 包全名</code> 时要特别注意后面加的是包全名，而不是包名，不过查询未安装的软件包的信息，这样的命令不是很常用。</p>
<p><strong>RPM 包查询包中的文件的安装位置</strong></p>
<p>RPM 包的安装位置是默认的，一般不会修改，包中文件的安装位置在组件包的时候就已经决定了，我们可以查询包下文件的安装位置。</p>
<p><code>rpm –ql 包名</code></p>
<p>选项：</p>
<ul>
<li>-l  列表（list）</li>
<li>-p  查询未安装包信息（package） ，注意后面要添加包全名而不是包名</li>
</ul>
<p><strong>查询系统文件属于哪一个RPM 包</strong></p>
<p><code>rpm –qf 系统文件名</code></p>
<p>选项：</p>
<ul>
<li>-f  查询系统文件属于哪个软件包（file）</li>
</ul>
<p>注意后面添加的文件名不应该是手工创建的文件、系统产生的临时文件或者日志文件等，必须是软件包安装时产生的系统文件。</p>
<p><strong>RPM 包查询软件包的依赖性</strong></p>
<p><code>rpm –qR 包名</code></p>
<p>选项：</p>
<ul>
<li>-R  查询软件包的依赖性（requires）</li>
<li>-p  查询未安装包信息（package），注意后面要添加包全名</li>
</ul>
<p><strong>RPM 包校验</strong></p>
<p>RPM 包的校验主要是用来验证软件包对应的系统文件是否被修改。</p>
<p><code>rpm –V 已安装的包名</code></p>
<p>选项：</p>
<ul>
<li>-V  校验指定RPM包中的文件（verify）</li>
</ul>
<p>如果命令执行后没有输出提示，则表示系统文件没有被修改，否则说明系统文件被修改。输出的提示信息包含以下几方面的内容：</p>
<blockquote>
<p>S  文件大小是否改变<br>M  文件的类型或文件的权限（rwx）是否被改变<br>5  文件MD5校验和是否改变（可以看成文件内容是否改变）<br>D  设备的中，从代码是否改变<br>L  文件路径是否改变<br>U  文件的属主（所有者）是否改变<br>G  文件的属组是否改变<br>T  文件的修改时间是否改变</p>
</blockquote>
<p>而输出结果中的文件类型包括如下几种：</p>
<blockquote>
<p>c  配置文件（config file）<br>d  普通文档（documentation）<br>g  “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM包包含<br>l  授权文件（license file）<br>r  描述文件（read me）</p>
</blockquote>
<p>以验证Apache 软件包为例，修改Apache 的配置文件，默认路径为 <code>/etc/httpd/conf/http.conf</code>，之后执行命令 <code>rpm -V httpd</code>，输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">S.<span class="number">5</span>....T. <span class="keyword">c</span> /etc/httpd/<span class="keyword">conf</span>/http.<span class="keyword">conf</span></div></pre></td></tr></table></figure>

<p><strong>RPM 包中的文件提取</strong></p>
<p>该命令可以提取出RPM 包中某一个指定的系统文件，比如说由于误操作将重要的系统文件删除了，此时不需要重新安装系统，甚至不需要重新安装软件，我们只需要知道删除的系统文件属于哪一个RPM 包，然后从RPM 包中提取出相应的系统文件，覆盖该文件之前的路径即可。因此可以说提取命令主要是用来进行软件包恢复的。</p>
<p><code>rpm2cpio 包全名  |  \
cpio -idv .文件绝对路径</code></p>
<p>注意上述命令中的反斜杠 <code>\</code> 表示一条命令没有输完，<code>.</code> 表示提取文件到当前路径。rpm2cpio 是将rpm包转换为cpio格式的命令，而cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件。它的具体使用方法如下：</p>
<p><code>cpio 选项 &lt; [文件|设备]</code></p>
<p>选项：</p>
<ul>
<li>-i：copy-in模式，还原（提取）</li>
<li>-d：还原时自动新建目录</li>
<li>-v：显示还原过程</li>
</ul>
<p>下面以误删除 <code>ls</code> 系统命令为例进行讲解：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rpm -qf /bin/<span class="keyword">ls</span> 	</div><div class="line">#查询<span class="keyword">ls</span>命令属于哪个软件包，若文件已经丢失，可通过其他途径查询所属软件包</div><div class="line">mv /bin/<span class="keyword">ls</span> /tmp/	</div><div class="line">#造成<span class="keyword">ls</span>命令误删除假象</div><div class="line">rpm2cpio /mnt/cdrom/Packages/coreutils-<span class="number">8.4</span>-<span class="number">19</span>.el6.i686.rpm | cpio -idv ./bin/<span class="keyword">ls</span></div><div class="line">#提取RPM包中<span class="keyword">ls</span>命令到当前目录的/bin/<span class="keyword">ls</span>下</div><div class="line"><span class="keyword">cp</span> /root/bin/<span class="keyword">ls</span> /bin/	</div><div class="line">#把<span class="keyword">ls</span>命令复制会/bin/目录，修复文件丢失</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>这篇博客中我们首先讲述了RPM 包和源码包的优缺点，然后详细讲述了RPM 包手工管理的几条rpm 命令，主要包括：</p>
<ol>
<li><strong>RPM 包的安装</strong>        <code>rpm –ivh 包全名</code></li>
<li><strong>RPM 包的升级</strong>        <code>rpm -Uvh 包全名</code></li>
<li><strong>RPM 包卸载</strong>        <code>rpm –qa</code></li>
<li><strong>RPM 包查询是否安装</strong>    <code>rpm -q 包名</code> </li>
<li><strong>RPM 包查询详细信息</strong>        <code>rpm –qi 包名</code></li>
<li><strong>RPM 包查询包中的文件的安装位置</strong>        <code>rpm –ql 包名</code>    </li>
<li><strong>查询系统文件属于哪一个RPM 包</strong>            <code>rpm –qf 系统文件名</code></li>
<li><strong>RPM 包查询软件包的依赖性</strong>            <code>rpm –qR 包名</code></li>
<li><strong>RPM 包校验</strong>        <code>rpm –V 已安装的包名</code></li>
<li><strong>RPM 包中的文件提取</strong>        <code>rpm2cpio 包全名  |  cpio -idv .文件绝对路径</code></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="软件包管理简介">软件包管理简介</h2>
<p>Linux 中的可以安装的软件包可以分为两类：源码包和二进制包，其中源码包绝大部分是用C 语言写的，而二进制包又叫做RPM 包，是已经编译好的安装包，也是系统默认包，这两类安装包有各自的优缺点。</p>
<p>源码包的优点是：</p>
<ol>
<li>开源，如果有足够的能力，可以修改源代码；</li>
<li>可以自由选择所需的功能；</li>
<li>软件是编译安装，所以更加适合自己的系统，比起RPM包更加稳定也效率更高；</li>
<li>卸载方便。</li>
</ol>
<p>源码包的缺点是：</p>
<ol>
<li>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误；</li>
<li>编译过程时间较长，安装比二进制安装时间长；</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决。</li>
</ol>
]]>
    
    </summary>
    
      <category term="linux" scheme="http://zhangyigong.github.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 编辑器的使用]]></title>
    <link href="http://zhangyigong.github.com/2015/03/03/vim-basic-operations/"/>
    <id>http://zhangyigong.github.com/2015/03/03/vim-basic-operations/</id>
    <published>2015-03-03T14:42:32.000Z</published>
    <updated>2015-03-09T02:22:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>Vim 编辑器是在Linux 系统下常用的一款全屏幕文本编辑器，它用来建立、编辑和显示配置文件、shell 脚本等文本文件。Vim 并没有菜单，<strong>只有命令</strong>。</p>
<h2 id="Vim_工作模式">Vim 工作模式</h2>
<p>Vim 包含三种工作模式：命令模式、插入模式和编辑模式。不同模式之间的转换关系如下图所示。</p>
<p>执行命令 <code>vi filename</code> 后，不论filename 是新建的文件还是已经存在的文件，此时vim 进入的就是命令模式。此时输入任何字符，系统都会当做命令来处理，而不会在文件内容中进行显示。</p>
<p>如果想向文件中插入内容，则需要切换到插入模式。进入插入模式可以输入并执行插入命令，比如说 <code>i</code> 。如果想退出插入模式回到命令模式，则可以在键盘上摁下 <code>Esc</code> 键。</p>
<p>在命令模式下可以通过执行命令来删除和恢复文件中的内容。</p>
<a id="more"></a>

<p>而vim 可以通过输入冒号 <code>:</code> 来切换到编辑模式，比如要设置行号 <code>:set nu</code> 是编辑模式下的命令，<code>:wq</code> 是编辑模式下保存退出的命令。编辑模式下的命令执行完之后会自动切换到命令模式，所以要注意只有在冒号 <code>:</code> 之后输入的命令才是编辑模式下的命令。</p>
<p><img src="http://zhang1g.qiniudn.com/vim-gzmoshi.PNG" alt="Vim 的工作模式"></p>
<h2 id="Vim_常用命令">Vim 常用命令</h2>
<p><strong>插入命令</strong></p>
<ul>
<li><code>a</code>        在光标所在字符后插入</li>
<li><code>A</code>        在光标所在行尾插入</li>
<li><code>i</code>        在光标所在字符前插入</li>
<li><code>I</code>        在光标所在行行首插入</li>
<li><code>o</code>        在光标下插入新行</li>
<li><code>O</code>        在光标上插入新行</li>
</ul>
<p>使用插入命令需要注意的是，插入完成之后记得摁下键盘上的 <code>Esc</code> 来退回到命令模式。</p>
<p><strong>定位命令</strong></p>
<ul>
<li><code>:set nu</code>        设置行号</li>
<li><code>:set nonu</code>    取消设置行号</li>
<li><code>gg</code>            光标跳转到第一行</li>
<li><code>G</code>            光标跳转到最后一行</li>
<li><code>nG</code>/<code>:n</code>        光标跳转到第n行</li>
<li><code>$</code>            光标移至行尾</li>
<li><code>0</code>            光标移至行首</li>
</ul>
<p><strong>删除命令</strong></p>
<ul>
<li><code>x</code>            删除光标所在处的字符</li>
<li><code>nx</code>            删除光标所在处后的n 个字符</li>
<li><code>dd</code>            删除光标所在行</li>
<li><code>ndd</code>            删除光标所在行在内的n 行</li>
<li><code>dG</code>            删除光标所在行到文件末尾的内容</li>
<li><code>D</code>            删除光标所在处到行尾的内容</li>
<li><code>:n1,n2d</code>        删除指定范围的行</li>
</ul>
<p><strong>复制和剪切命令</strong></p>
<ul>
<li><code>yy</code>            复制当前行</li>
<li><code>nyy</code>            复制当前行以下n行</li>
<li><code>dd</code>            剪切当前行，和删除光标所在行命令一样</li>
<li><code>ndd</code>            剪切当前行以下n 行</li>
<li><code>p</code>            粘贴在当前光标所在的行下</li>
<li><code>P</code>            粘贴在当前光标所在的行上</li>
</ul>
<p><strong>替换和取消命令</strong></p>
<ul>
<li><code>r</code>            取代光标所在处的字符</li>
<li><code>R</code>            从光标所在处开始替换字符，按 <code>Esc</code> 键结束</li>
<li><code>u</code>            取消上一步的操作</li>
</ul>
<p><strong>搜索和搜索替换命令</strong></p>
<ul>
<li><code>/string</code>                搜索指定字符串，默认搜索时<strong>不忽略</strong>大小写</li>
<li><code>:set ic</code>                设置搜索时忽略大小写</li>
<li><code>:set noic</code>            设置搜索时不忽略大小写</li>
<li><code>n</code>                    搜索指定字符串的下一个出现位置</li>
<li><code>:%s/old/new/g</code>        全文替换指定字符串，如果最后一个参数为 <code>c</code>，则替换时会挨个询问</li>
<li><code>:n1,n2s/old/new/g</code>    在一定范围内替换指定字符串</li>
</ul>
<p><strong>保存和退出命令</strong></p>
<ul>
<li><code>:w</code>                保存修改</li>
<li><code>:w new_file</code>        另存为指定文件</li>
<li><code>:wq</code>                保存修改并退出</li>
<li><code>ZZ</code>                快捷键，保存修改并退出</li>
<li><code>:q!</code>                不保存修改退出</li>
<li><code>:wq!</code>            保存修改并退出（文件所有者以及root可使用）</li>
</ul>
<p>这里需要注意的是最后一个命令，它操作的是只读文件，即包括文件所有者都没有写权限的文件，此时仍然可以保存修改，但是不是所有用户都可以执行此操作。</p>
<h2 id="Vim_使用技巧">Vim 使用技巧</h2>
<p><strong>导入命令的执行结果</strong></p>
<p>使用命令 <code>:r filename</code> 可以将文件filename 中的内容复制到正在操作的文件中，而使用命令 <code>:! cmd</code> 可以在Vim 环境下执行linux 命令。</p>
<p>在上面两点的基础上，可以通过执行命令 <code>:r !cmd</code> 将cmd 命令的执行结果复制到正在操作的文件中。比如说 <code>:r !date</code> 可以将当前的时间信息输出到正在操作的文件。<br>:<br><strong>定义快捷键</strong></p>
<p>可以使用 <code>:map 快捷键 触发命令</code> 的模式定义Vim 的操作快捷键。</p>
<p>比如说 <code>:map ^P I#&lt;ESC&gt;</code> 将 ctrl+p 定义为在行首添加注释的快捷键，<code>:map ^B 0x</code> 将 ctrl+b 定义为去掉行首注释的快捷键。</p>
<p>需要注意的是命令中出现的 <code>^P</code> 不是手工输入的，而是通过 <code>ctrl+v+p</code> 输入的。</p>
<p><strong>连续行注释</strong></p>
<p><code>:n1,n2s/^/#/g</code>        进行连续的行首注释<br><code>:n1,n2s/^#//g</code>        取消连续几行的行首注释<br><code>:n1,n2s/^\/\//g</code>     连续添加其他类型的行首注释</p>
<p><strong>替换</strong></p>
<p><code>:ab mymail zhangxx@163.com</code> 在使用Vim进行编辑时输入mymail 后添加空格或者换行，即可进行替换。</p>
<p>需要注意的是，在vim 的命令模式下添加了快捷键和替换之后，重启系统设置是不会继续生效的，而且在编辑其他文件时也不会生效，因此如果想一直对所有文件生效则需要将修改写入配置文件。具体位置为root用户的 /root目录或者普通用户的home 目录下的 <code>.vimrc</code> 文件，如果没有该文件可以自行添加。在该文件中添加命令是不需要输入冒号的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>Vim 编辑器是在Linux 系统下常用的一款全屏幕文本编辑器，它用来建立、编辑和显示配置文件、shell 脚本等文本文件。Vim 并没有菜单，<strong>只有命令</strong>。</p>
<h2 id="Vim_工作模式">Vim 工作模式</h2>
<p>Vim 包含三种工作模式：命令模式、插入模式和编辑模式。不同模式之间的转换关系如下图所示。</p>
<p>执行命令 <code>vi filename</code> 后，不论filename 是新建的文件还是已经存在的文件，此时vim 进入的就是命令模式。此时输入任何字符，系统都会当做命令来处理，而不会在文件内容中进行显示。</p>
<p>如果想向文件中插入内容，则需要切换到插入模式。进入插入模式可以输入并执行插入命令，比如说 <code>i</code> 。如果想退出插入模式回到命令模式，则可以在键盘上摁下 <code>Esc</code> 键。</p>
<p>在命令模式下可以通过执行命令来删除和恢复文件中的内容。</p>
]]>
    
    </summary>
    
      <category term="linux" scheme="http://zhangyigong.github.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式概述与面向对象设计原则（二）]]></title>
    <link href="http://zhangyigong.github.com/2015/02/04/design-pattern-and-design-principles-second/"/>
    <id>http://zhangyigong.github.com/2015/02/04/design-pattern-and-design-principles-second/</id>
    <published>2015-02-04T07:24:33.000Z</published>
    <updated>2015-03-09T02:17:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在上一篇博客中我们只讲述的7中面向对象设计原则中的2种，下面是剩余5种设计模式的详细内容，包括：</p>
<ul>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>合成复用原则</li>
<li>迪米特法则</li>
</ul>
<h2 id="里氏代换原则">里氏代换原则</h2>
<p>里氏代换原则的一个通俗的定义是：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<p><strong>里氏代换原则是实现开闭原则的重要方式之一</strong>，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p>
<a id="more"></a>

<p>一个简单的例子如下：</p>
<p><img src="http://my.csdn.net/uploads/201205/06/1336312710_1412.jpg" alt="不好的设计"></p>
<p>在原本的设计中，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复。<br>可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer 和VIPCustomer 类作为其子类，邮件发送类EmailSender 类针对抽象客户类Customer 编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender 中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer 类的子类即可。</p>
<p>修改后的结构如下</p>
<p><img src="http://my.csdn.net/uploads/201205/06/1336312720_2300.jpg" alt="好的设计"></p>
<p>在上面的例子中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。</p>
<h2 id="依赖倒转原则">依赖倒转原则</h2>
<p>依赖倒转原则通俗的来说就是<strong>要针对接口编程，而不要针对实现编程</strong>。</p>
<p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，<strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入</strong>。</p>
<p>一个简单的例子如下</p>
<p><img src="http://my.csdn.net/uploads/201205/13/1336909329_9009.jpg" alt="不好的设计"></p>
<p>CustomerDAO 将存储在TXT或Excel文件中的客户信息转存到数据库中，需要调用数据格式转换类中的方法。但是由于CustomerDAO 针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO 的源代码。我们可以通过引入抽象数据转换类解决该问题</p>
<p><img src="http://my.csdn.net/uploads/201205/13/1336909334_4352.jpg" alt="好的设计"></p>
<p>在修改之后的设计中，CustomerDAO 针对抽象类DataConvertor 编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。</p>
<p>在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，<strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段</strong>，它们相辅相成，相互补充。</p>
<h2 id="接口隔离原则">接口隔离原则</h2>
<p>接口隔离原则指的是使用多个专门的接口，而不使用单一的总接口，即<strong>客户端不应该依赖那些它不需要的接口</strong>。</p>
<p>下面通过一个简单实例来加深理解：</p>
<p><img src="http://my.csdn.net/uploads/201205/13/1336910243_3390.jpg" alt="不好的设计"></p>
<p>CustomerDataDisplay 接口中的方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML 格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。</p>
<p>由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。</p>
<p>使用接口隔离原则进行重构后的结构如下</p>
<p><img src="http://my.csdn.net/uploads/201205/13/1336910247_6209.jpg" alt="好的设计"></p>
<h2 id="合成复用原则">合成复用原则</h2>
<p>合成复用原则指的是<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。</p>
<h2 id="迪米特法则">迪米特法则</h2>
<p>迪米特法则指的是<strong>一个软件实体应当尽可能少地与其他实体发生相互作用</strong>。可以形象地理解为不要和“陌生人”说话、只与你的直接朋友通信。在迪米特法则中，对于一个对象，其朋友包括以下几类：</p>
<ol>
<li>当前对象本身(this)；</li>
<li>以参数形式传入到当前对象方法中的对象；</li>
<li>当前对象的成员对象；</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li>
<li>当前对象所创建的对象。</li>
</ol>
<p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以<strong>通过第三者转发这个调用</strong>。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>
<p>为了便于理解，给出一个简单的例子</p>
<p><img src="http://my.csdn.net/uploads/201205/14/1336930654_2743.jpg" alt="不好的设计"></p>
<p>界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变。</p>
<p>由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p>
<p>现使用迪米特对其进行重构。</p>
<p><img src="http://my.csdn.net/uploads/201205/14/1336930673_6550.jpg" alt="好的设计"></p>
<p>可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，</p>
<h2 id="总结">总结</h2>
<p>关于面向对象设计原则，我们使用通俗的方式进行概括总结。</p>
<ul>
<li>单一职责原则要求在设计时一个类只负责一个功能领域中的相应职责，应该只有一个引起它变化的原因。</li>
<li>开闭原则指的是一个软件实体应该尽量在不修改原有代码的情况下进行扩展。</li>
<li>里氏代换原则要求所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li>
<li>依赖倒转原则要求针对接口编程，而不要针对实现编程，针对抽象层编程时，需要将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。</li>
<li>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，不可分割。</li>
<li>接口隔离原则指的是使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li>
<li>合成复用原则指的是尽量使用对象组合，而不是继承来达到复用的目的。</li>
<li>迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用，对于不直接通信的类对象，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>在上一篇博客中我们只讲述的7中面向对象设计原则中的2种，下面是剩余5种设计模式的详细内容，包括：</p>
<ul>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>合成复用原则</li>
<li>迪米特法则</li>
</ul>
<h2 id="里氏代换原则">里氏代换原则</h2>
<p>里氏代换原则的一个通俗的定义是：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<p><strong>里氏代换原则是实现开闭原则的重要方式之一</strong>，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p>
]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://zhangyigong.github.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式概述与面向对象设计原则（一）]]></title>
    <link href="http://zhangyigong.github.com/2015/02/04/design-pattern-and-design-principles-first/"/>
    <id>http://zhangyigong.github.com/2015/02/04/design-pattern-and-design-principles-first/</id>
    <published>2015-02-04T01:50:16.000Z</published>
    <updated>2015-03-07T15:53:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="设计模式概述">设计模式概述</h2>
<p>设计模式从本质上来看，是众多代码复用手段中的一种，他最早由GOF（四人帮）在《设计模式——可复用面向对象软件的基础》一书中提出。要学懂设计模式，必须要首先理解设计模式的真实意图 — <strong>可复用面向对象软件的基础</strong>，这正是那本著作的副标题。    </p>
<p>下面给出设计模式的定义：</p>
<blockquote>
<p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
</blockquote>
<p>一个成熟的设计模式一般包含以下几部分：</p>
<ol>
<li>模式名称（Patthern Name）    </li>
<li>问题（Problem）</li>
<li>解决方案（Solution）</li>
<li>效果（Consequences）</li>
</ol>
<a id="more"></a> 

<p><strong>模式名称</strong>主要是方便开发人员交流，一般是根据设计模式的功能或者结构来命名的。<strong>问题</strong>描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。<strong>解决方案</strong>描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述。<strong>效果</strong>描述了模式的优缺点以及在使用模式时应权衡的问题。</p>
<p>根据设计模式的用途可以分为创建型（Creational），结构型（Structural）和行为型（Behavioral）三种。其中</p>
<ul>
<li>创建型模式主要用于描述如何创建对象（5种）</li>
<li>结构型模式主要用于描述如何实现类或对象的组合（7种）</li>
<li>行为型模式主要用于描述类或对象怎样交互以及怎样分配职责（11种）</li>
</ul>
<p>设计模式还可以分为类模式和对象模式。我们经常将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。</p>
<p>值得注意的是，简单工厂模式因为太简单了，因此没有放到这23种设计模式当中。</p>
<h2 id="面向对象设计原则">面向对象设计原则</h2>
<p>面向对象设计原则共包括7个：</p>
<ol>
<li>单一职责原则 — 一个类只负责一个功能领域中的相应职责</li>
<li>开闭原则         — 软件实体应对扩展开放，而对修改关闭</li>
<li>里氏代换原则    — 所有引用基类对象的地方能够透明地使用其子类的对象        </li>
<li>依赖倒转原则 — 抽象不应该依赖于细节，细节应该依赖于抽象</li>
<li>接口隔离原则 — 使用多个专门的接口，而不使用单一的总接口</li>
<li>合成复用原则 — 尽量使用对象组合，而不是继承来达到复用的目的</li>
<li>迪米特法则    — 一个软件实体应当尽可能少地与其他实体发生相互作用</li>
</ol>
<p>下面讲述各个设计原则的详细内容，其中用到的实际例子均来自于<a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">刘伟技术博客</a>中讲解设计原则的相关内容。</p>
<p><strong>单一职责原则</strong></p>
<p>单一职责可以从另外一个角度理解：<strong>对一个类而言，应该只有一个引起它变化的原因</strong>。它是实现软件设计高内聚、低耦合的指导方针。</p>
<p>一个简单的例子如下：</p>
<p><img src="http://my.csdn.net/uploads/201205/05/1336147233_3529.jpg" alt="不好的实现"></p>
<p>图中的CustomerDataChart 类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p>
<p>CustomerDataChart 类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。</p>
<p>如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart 可拆分为如下三个类：</p>
<ol>
<li><strong>DBUtil</strong>：负责连接数据库，包含数据库连接方法getConnection()；</li>
<li><strong>CustomerDAO</strong>：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</li>
<li><strong>CustomerDataChart</strong>：负责图表的生成和显示，包含方法createChart()和displayChart()。</li>
</ol>
<p>使用单一职责原则重构后的结构如下所示：</p>
<p><img src="http://my.csdn.net/uploads/201205/05/1336147240_4896.jpg" alt="好的实现"></p>
<p><strong>开闭原则</strong></p>
<p>开闭原则指的是一个软件实体应该尽量在不修改原有代码的情况下进行扩展。一个软件实体可以指一个独立的类，也可以是由多个类组成的一个局部结构。</p>
<p>软件系统的扩展和维护会随着需求的变化而经常发生，利用开闭原则对系统进行扩展的时候，需要对系统进行抽象化设计，具体表现为可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>
<p>一个例子如下：</p>
<p><img src="http://my.csdn.net/uploads/201205/05/1336201566_1496.jpg" alt="不好的实现"></p>
<p>ChartDisplay 可以显示各种类型的图表，如饼状图和柱状图等。在ChartDisplay 类的display()方法中存在如下代码片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">...</span><span class="attribute">...</span>  </div><div class="line"><span class="keyword">if</span> (<span class="keyword">type</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="string">"pie"</span>)) {  </div><div class="line">    PieChart chart <span class="subst">=</span> <span class="literal">new</span> PieChart();  </div><div class="line">    chart<span class="built_in">.</span>display();  </div><div class="line">}  </div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="string">"bar"</span>)) {  </div><div class="line">    BarChart chart <span class="subst">=</span> <span class="literal">new</span> BarChart();  </div><div class="line">    chart<span class="built_in">.</span>display();  </div><div class="line">}  </div><div class="line"><span class="attribute">...</span><span class="attribute">...</span></div></pre></td></tr></table></figure>

<p>这样如果要新增一个图标类，如折线图，则需要修改ChartDisplay 类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p>
<p>可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p>
<ol>
<li>增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</li>
<li>ChartDisplay 类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201205/05/1336201573_6059.jpg" alt="好的实现"></p>
<p>在修改过的实现中，我们引入了抽象图表类AbstractChart，且ChartDisplay 针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay 的display()方法中调用chart 对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart 也作为AbstractChart 的子类，在客户端向ChartDisplay 中注入一个LineChart对象即可，无须修改现有类库的源代码。     </p>
<p>需要注意，因为xml 和properties 等格式的配置文件是纯文本文件，可以直接通过VI 编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。</p>
<p>由于篇幅的限制这一篇博客中只讲述2种设计原则，剩余4种设计原则的详细内容在下一篇博客中讲述。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="设计模式概述">设计模式概述</h2>
<p>设计模式从本质上来看，是众多代码复用手段中的一种，他最早由GOF（四人帮）在《设计模式——可复用面向对象软件的基础》一书中提出。要学懂设计模式，必须要首先理解设计模式的真实意图 — <strong>可复用面向对象软件的基础</strong>，这正是那本著作的副标题。    </p>
<p>下面给出设计模式的定义：</p>
<blockquote>
<p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
</blockquote>
<p>一个成熟的设计模式一般包含以下几部分：</p>
<ol>
<li>模式名称（Patthern Name）    </li>
<li>问题（Problem）</li>
<li>解决方案（Solution）</li>
<li>效果（Consequences）</li>
</ol>
]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://zhangyigong.github.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL 基础（番外篇）解决Mysql 的中文乱码问题]]></title>
    <link href="http://zhangyigong.github.com/2015/01/27/solve-mysql-messy-code/"/>
    <id>http://zhangyigong.github.com/2015/01/27/solve-mysql-messy-code/</id>
    <published>2015-01-27T07:17:15.000Z</published>
    <updated>2015-03-09T02:29:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在<a href="http://zhangyigong.github.com/2015/01/27/database-and-sql/" target="_blank" rel="external">SQL 基础（一） 数据库和SQL</a>一文中，最后我们使用Mysql 在向表中插入汉字时出现了乱码。在实际工作中，乱码问题也时常发生，令人头痛。</p>
<p>比如在Mysql 数据库插入下面一条带有中文的数据，在查询时结果集中很容易出现乱码。</p>
<figure class="highlight `"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee <span class="keyword">VALUES</span>(<span class="literal">null</span>,<span class="string">'张三'</span>,<span class="string">'male'</span>,<span class="string">'1995-10-08'</span>,</span></div><div class="line">	<span class="string">'2015-01-12'</span>,<span class="string">'Sales'</span>,<span class="number">2000</span>,<span class="string">'是个好员工！'</span>);</div></pre></td></tr></table></figure>

<p>关于解决Mysql 中文乱码问题，在网上有多方法，这里我希望通过这篇博客来捋清楚使用Mysql 时产生乱码问题的前因后果，以及相应的解决方法。其中借鉴了网上一些内容，我会在博客的最后列出相关的链接，感谢这些作者。</p>
<h2 id="Mysql_和字符集相关的变量">Mysql 和字符集相关的变量</h2>
<p>首先，我们不带任何参数启动Mysql 服务，然后在Mysql 的命令行客户端执行语句 <code>show variables like &#39;character_set%&#39;;</code> ，查看Mysql 使用的字符集的变量有哪些，显示如下的结果</p>
<a id="more"></a>

<p><img src="http://zhang1g.qiniudn.com/show_character_set_variables.PNG" alt="查看Mysql 的默认字符集"></p>
<p>有上图中可以看到，Mysql 中共有6 处使用了字符集，分别是：client 、connection、database、results、server 和system。其中与服务器相关的是：database、server、system（永远无法修改，就是utf-8），与客户端相关的是：connection、client、results 。</p>
<p>或者可以在命令行客户端输入 <code>status;</code>，也可以看到与字符编码相关的变量。</p>
<p><img src="http://zhang1g.qiniudn.com/statuus.PNG" alt="查看Mysql 的默认字符集"></p>
<p>下面对这些变量做一个简单的介绍</p>
<table>
<thead>
<tr>
<th>和字符集相关的变量</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>client</strong></td>
<td style="text-align:left">为客户端使用的字符集</td>
</tr>
<tr>
<td><strong>connection</strong></td>
<td style="text-align:left">为连接数据库的字符集设置类型，如果程序没有指明连接数据库使用的字符集类型则按照服务器端默认的字符集设置</td>
</tr>
<tr>
<td><strong>database</strong></td>
<td style="text-align:left">为数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装时指定的字符集设置</td>
</tr>
<tr>
<td><strong>results</strong></td>
<td style="text-align:left">为数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集</td>
</tr>
<tr>
<td><strong>server</strong></td>
<td style="text-align:left">为服务器安装时指定的默认字符集设定</td>
</tr>
<tr>
<td><strong>system</strong></td>
<td style="text-align:left">为数据库系统使用的字符集设定</td>
</tr>
</tbody>
</table>
<h2 id="出现乱码的原因">出现乱码的原因</h2>
<p>了解上面的信息之后，我们来分析<a href="http://zhangyigong.github.com/2015/01/27/database-and-sql/" target="_blank" rel="external">SQL 基础（一） 数据库和SQL</a>一文中产生乱码的原因。我们发现除了默认的system 变量编码为utf-8 外，其余变量的编码格式为latin1，因此当向表中插入中文字符时才会出现乱码。</p>
<p>不同的编码格式会导致,同一字符在不同字符集下的编码会不同。同样同一编码在不同的字符集中代码的字符也不相同。当MySQL 返回的字符串的编码格式（字符集）与你的客户工具程序（mysql客户端, php, java, query browser, …）当前使用的字符集不同时，就会造成乱码。</p>
<p>MySQL 中默认字符集的设置有四级：<strong>服务器级</strong>，<strong>数据库级</strong>，<strong>表级</strong> 以及<strong>字段级</strong>的字符集设置。注意前三种均为默认设置，并不代表字段最终会使用这个字符集设置。所以建议要用 <code>show create table tablename ;</code> 或 <code>show full fields from tableName;</code> 来检查当前表中字段的字符集设置。</p>
<p><img src="http://zhang1g.qiniudn.com/show-create-table-name.PNG" alt="Mysql 查看表中字段的 字符集设置"></p>
<p>我们已经知道，MySQL 中关于连接环境的字符集设置有client，connection， results，通过这些参数，MySQL 就知道你的客户端工具用的是什么字符集，结果集应该是什么字符集。这样MySQL 就会做必要的翻译，一旦这些参数有误，自然会导致字符串在转输过程中的转换错误。基本上99%的乱码由些造成。</p>
<h2 id="出现乱码的解决方法">出现乱码的解决方法</h2>
<p>根据上面的分析，我们得出Mysql 向表中插入中文数据时出现乱码的原因有如下2 个：</p>
<ol>
<li>表中字段的字符集没有设置为中文兼容（GBK/GB2312/UTF8）</li>
<li>Mysql 相关的参数字符集设置不统一，尤其是变量client，connection, results</li>
</ol>
<p>针对上面的问题，我们采取的方法步骤如下：</p>
<p><strong>修改server 和database 的编码格式</strong> </p>
<p>通过执行 <code>status;</code> 命令，我们已经发现发现sever 和database 的字符集目前为默认字符集latin1，需要修改为utf8 编码。在Mysql 安装文件夹下找到文件 <code>my.ini</code>，并修改server 和database 的字符编码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">...</span></div><div class="line">[mysql]</div><div class="line">default-character-set=utf8</div><div class="line"><span class="keyword">...</span></div><div class="line">[mysqld]</div><div class="line">default-character-set=utf8</div></pre></td></tr></table></figure>

<p>修改之后重新启动Mysql 服务和客户端，server 和database 的字符集编码就改变了，但是我们之前创建的数据库shop 的编码仍然是latin1，此时我们可以选择删除数据库shop并重新创建，也可以通过下面的命令直接修改数据库shop 的编码格式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> shop <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> UTF8 <span class="keyword">COLLATE</span> UTF8_BIN;</span></div></pre></td></tr></table></figure>

<p>之后执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> <span class="title">shop</span>;</div><div class="line">status;</div></pre></td></tr></table></figure>

<p>此时我们发现database shop 的编码已经变为utf8。</p>
<p><strong>修改表和字段的编码</strong></p>
<p>此时执行 <code>SELECT * FROM Product;</code>，我们发现查询的结果仍然显示乱码。现在我们需要执行命令将表和包含中文的字段对应的字符集也设置成UTF8，但是由于之前我们已经在数据库中插入了数据，所以需要先将表中的内容清空，注意备份数据，将之前向表中插入数据的脚本保存为sql 文件。</p>
<p>执行命令 <code>TRUNCATE TABLE Product;</code> 可以将表Product 中的内容清空。</p>
<p>在修改了shop 数据库的编码格式之后，修改表Product 和各个字段编码的具体代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Product <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8;</span></div><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Product MODIFY product_id <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> UTF8 <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></div><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Product MODIFY product_name <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> UTF8  <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></div><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Product MODIFY product_id <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> UTF8 <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></div><div class="line"><span class="operator"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Product;</span></div></pre></td></tr></table></figure>

<p>我们发现表和字段都变成UTF8编码了，之后我们执行之前保存的向表中插入数据的sql 脚本,非常不幸，在插入数据时出现了如下所示的错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">mysql&gt;</span> <span class="constant">INSERT</span> <span class="constant">INTO</span> <span class="constant">Product</span> <span class="constant">VALUES</span> (<span class="string">'0001'</span>,<span class="string">'T恤衫'</span>,<span class="string">'衣服'</span>,<span class="number">1000</span>,<span class="number">500</span>,<span class="string">'2009-09-20'</span>);</span></div><div class="line"></div><div class="line">**<span class="constant">ERROR</span> <span class="number">1406</span> (<span class="number">22001</span>)<span class="symbol">:</span> <span class="constant">Data</span> too long for column <span class="string">'product_name'</span> at row <span class="number">1</span>**</div></pre></td></tr></table></figure>

<p>乍一看，是字段长度引起的问题，但是实际是还是字符编码的问题，如果我们是在Linux 下的终端执行命令，或者使用Java等编写客户端代码时遇到这种错误，可以在执行inser、select、update 命令之前输入下面的命令即可解决。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">set</span> <span class="keyword">names</span> utf8;</span></div></pre></td></tr></table></figure>

<p>这条命令相当于同时设定client、connection、results 的字符编码为utf8。该命令将终端的字符编码设为了UTF8。此后再插入数据库中的内容都会按照UTF8的编码来处理。</p>
<p>但是在Windows下，Mysql 客户端命令行窗口不支持UTF8编码，所以使用 <code>set names utf8;</code> 不会达到转化中文的效果。但是这个问题还是可以解决的，可以放弃命令行窗口登录MySQL，使用图形化客户端，也可以修改Mysql 安装路径下的 <code>my.ini</code> 文件，在[client]下面，加上 <code>default-character-set=utf8</code>，并将[mysql]下的默认编码格式改回来，改成 <code>default-character-set=latin1</code>，并重启Mysql 服务，之后再执行插入数据的脚本就没有问题了。<br>具体如下所示</p>
<p><img src="http://zhang1g.qiniudn.com/select-no-error-code.PNG" alt="成功解决Mysql中文乱码问题"></p>
<p>最终 <code>my.ini</code> 文件中配置如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[client]</div><div class="line">default-character-<span class="operator"><span class="keyword">set</span>=utf8</span></div><div class="line">[mysql]</div><div class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>=latin1</div><div class="line">[mysqld]</div><div class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>=utf8</div></pre></td></tr></table></figure>

<p><strong>在创建数据库和表时指定编码格式</strong></p>
<p>上面的内容是针对已经出现的乱码问题进行修改，那么我们是不是可以将乱码问题一开始就杜绝呢？当然可以在创建数据库和表时指定编码格式，具体如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">database</span> shop <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span></div><div class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> Product (</span></div><div class="line">	product_id <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">	...,</div><div class="line">	<span class="keyword">primary</span> <span class="keyword">key</span>(product_id)</div><div class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</div></pre></td></tr></table></figure>

<p>到目前为止我们就成功解决了Mysql 的中文乱码问题。</p>
<h2 id="总结">总结</h2>
<p>这篇博客整理分析了使用Mysql 时出现中文乱码的原因和解决方法，下面整理一下其中出现的SQL 语句，方便以后回顾</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'character_set%'</span>;</span></div><div class="line"><span class="operator"><span class="keyword">use</span> database_name;</span></div><div class="line">status;</div><div class="line"><span class="operator"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename;</span></div><div class="line"><span class="operator"><span class="keyword">alter</span> <span class="keyword">database</span> database_name <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span></div><div class="line"><span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span></div><div class="line"><span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> table_name modify column_name <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8 <span class="keyword">not</span> <span class="literal">null</span>;</span></div><div class="line"><span class="operator"><span class="keyword">set</span> <span class="keyword">names</span> utf8;</span></div><div class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">database</span> shop <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span></div><div class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> Product (</span></div><div class="line">	product_id <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">	...,</div><div class="line">	<span class="keyword">primary</span> <span class="keyword">key</span>(product_id)</div><div class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</div></pre></td></tr></table></figure>

<h2 id="参考文献">参考文献</h2>
<p><a href="http://www.cnblogs.com/sunzn/archive/2013/03/14/2960248.html" target="_blank" rel="external">MySQL 插入数据时，中文乱码问题的解决</a></p>
<p><a href="http://blog.csdn.net/blpluto/article/details/5704733" target="_blank" rel="external">MySQL插入显示汉字出现乱码问题的解决</a></p>
<p><a href="http://www.cnblogs.com/pricks/archive/2010/01/10/1643471.html" target="_blank" rel="external">mysql 插入中文乱码解决方案</a></p>
<p><a href="http://blog.csdn.net/ACMAIN_CHM/article/details/4174186" target="_blank" rel="external">MySQL 中文显示乱码</a></p>
<p><a href="http://blog.csdn.net/mydeman/article/details/1665997" target="_blank" rel="external">MySQL插入中文时出现ERROR 1406 (22001): Data too long for column ‘name’ at row 1</a></p>
<p><a href="http://blog.useasp.net/archive/2012/04/24/how_to_use_UTF8_encoding_in_Windows_CMD.aspx" target="_blank" rel="external">在Windows的CMD中如何设置支持UTF8编码?</a></p>
<p><a href="http://www.cnblogs.com/candle806/archive/2013/01/14/2859721.html" target="_blank" rel="external">mysql命令行修改字符编码</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>在<a href="http://zhangyigong.github.com/2015/01/27/database-and-sql/" target="_blank" rel="external">SQL 基础（一） 数据库和SQL</a>一文中，最后我们使用Mysql 在向表中插入汉字时出现了乱码。在实际工作中，乱码问题也时常发生，令人头痛。</p>
<p>比如在Mysql 数据库插入下面一条带有中文的数据，在查询时结果集中很容易出现乱码。</p>
<figure class="highlight `"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee <span class="keyword">VALUES</span>(<span class="literal">null</span>,<span class="string">'张三'</span>,<span class="string">'male'</span>,<span class="string">'1995-10-08'</span>,</span></div><div class="line">	<span class="string">'2015-01-12'</span>,<span class="string">'Sales'</span>,<span class="number">2000</span>,<span class="string">'是个好员工！'</span>);</div></pre></td></tr></table></figure>

<p>关于解决Mysql 中文乱码问题，在网上有多方法，这里我希望通过这篇博客来捋清楚使用Mysql 时产生乱码问题的前因后果，以及相应的解决方法。其中借鉴了网上一些内容，我会在博客的最后列出相关的链接，感谢这些作者。</p>
<h2 id="Mysql_和字符集相关的变量">Mysql 和字符集相关的变量</h2>
<p>首先，我们不带任何参数启动Mysql 服务，然后在Mysql 的命令行客户端执行语句 <code>show variables like &#39;character_set%&#39;;</code> ，查看Mysql 使用的字符集的变量有哪些，显示如下的结果</p>
]]>
    
    </summary>
    
      <category term="sql" scheme="http://zhangyigong.github.com/tags/sql/"/>
    
      <category term="数据库" scheme="http://zhangyigong.github.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="http://zhangyigong.github.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL基础（一） 数据库和SQL]]></title>
    <link href="http://zhangyigong.github.com/2015/01/27/database-and-sql/"/>
    <id>http://zhangyigong.github.com/2015/01/27/database-and-sql/</id>
    <published>2015-01-27T02:11:48.000Z</published>
    <updated>2015-03-09T02:16:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>总是感觉之前学的数据库相关的知识很零散，不够系统，加之好久没有看关于SQL 的知识，不免有点生疏了，于是想找一本合适的教材回顾一下。后来找到了一本可以堪称是零基础入门的SQL 书籍，这里给大家推荐一下：</p>
<p>《SQL 基础教程》 【日】MICK 著    孙淼 罗勇 译 </p>
<p>书中的SQL 都是基于标准SQL 2003编写，并且关于几个常用的RDBMS 在使用SQL 时的区别叙述的很详细，行文也很流畅，只是书中的命名都是按日文来的，不过影响不是很大。书中使用的RDBMS 是PostgreSQL，但是由于在实际中我使用Mysql 较多，所以我会主要侧重于Mysql 的相关部分。</p>
<p>下面就开始我们的SQL 之旅了。</p>
<h2 id="数据库是什么">数据库是什么</h2>
<p>很多人可能会觉得我们在使用计算机管理数据的时候，使用文本文件或者Excel 之类的电子表格软件不就可以了吗？为什么非要使用DBMS 这样专门的系统来管理数据呢？</p>
<a id="more"></a>

<p>因为使用文本文件或者Excel 如下的缺点：</p>
<ol>
<li>无法多人共享数据，即使文件放在连接网络的计算机上，并设置了网络共享，也存在某个用户打开文件的时候其他用户无法编辑的情况</li>
<li>无法提供操作大量数据所需的格式</li>
<li>实现读写自动化需要一定的编程能力</li>
<li>无法应对文件误删、硬盘故障等突发事件</li>
</ol>
<p>而DBMS 能够克服这些不足，实现多个用户简单安全地操作大量数据。</p>
<p><strong>DBMS 和RDBMS</strong></p>
<p>DBMS（数据库管理系统） 通过数据的保存格式进行划分，有以下5 钟类型</p>
<ol>
<li>层次型数据库</li>
<li>关系型数据库</li>
<li>面向对象数据库</li>
<li>XML 数据库</li>
<li>键值存储系统（NOSQL 数据库）</li>
</ol>
<p>这里我们介绍的主要是RDBMS（关系数据库管理系统），不过目前随着web2.0 的快速发展，也出现了很多优秀的NOSQL 数据库，有机会再分享相关的内容。</p>
<p>RDBMS 一般采用C/S 架构，由客户端和服务器组成，客户端向服务器发送SQL 语句，服务器进行处理，并按照语句的内容返回请求的数据，或者对存储在数据库中的内容进行更新。其中数据以二维表的形式存储在数据库服务器中，而<strong>返回的结果也是二维表的形式</strong>。另外，关系数据库必须<strong>以行（记录）为单位进行数据的读写操作</strong>。为了防止重要数据被窃取和篡改，RDBMS 只允许数据库的注册用户操作数据库，而注册用户最好设定密码。</p>
<p>常见的RDBMS 有：</p>
<ol>
<li>Oracle Database</li>
<li>SQL Server</li>
<li>DB2</li>
<li>PostgreSQL</li>
<li>MySQL</li>
</ol>
<h2 id="SQL_概要">SQL 概要</h2>
<p>一言以蔽之，SQL 是为了操作数据库而开发的语言。但是随着数据库的发展，出现了<strong>标准的SQL</strong> 和<strong>特定的SQL</strong>，标准的SQL 可以在不同的RDBMS 上执行，而特定的SQL 只能执行在特定的RDBMS 上执行。</p>
<p><strong>SQL 语句及其种类</strong></p>
<p>SQL 使用关键字、表名、列名组合成一条SQL 语句，根据指令种类的不同，可以分为以下3类</p>
<ul>
<li><strong>DDL（数据定义语言）</strong></li>
</ul>
<p>DDL 用来创建或者删除数据库或者数据库中的表对象等，它包含以下几种指令</p>
<p>CREATE：创建数据库和表等对象<br>DROP：    删除数据库和表等对象<br>ALTER：    修改数据库和表等对象的结构</p>
<ul>
<li><strong>DML（数据操作语言）</strong></li>
</ul>
<p>DML 用来查询或者变更表中的记录，它包含以下几种指令</p>
<p>SELECT：查询表中的数据<br>INSERT：向表中插入数据<br>UPDATE：变更表中的数据<br>DELETE：删除表中的数据</p>
<ul>
<li><strong>DCL（数据控制语言）</strong></li>
</ul>
<p>DCL 用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对用户权限进行设定，它包含以下几种指令</p>
<p>COMMIT：    确认对数据库中的数据进行变更<br>ROLLBACK：    取消对数据库中的数据进行的变更<br>GRANT：        赋予用户操作权限<br>REVOKE：    取消用户操作权限</p>
<p>上述类型的SQL 语句中，我们使用最多的是DML 类型的语句。</p>
<p>而在书写SQL 语句的过程中需要注意，SQL 语句都要以半角符号的分号 <code>;</code> 作为结束，SQL <strong>不区分关键字、表名、列名的大小写</strong>，但是插入到表中的数据是区分大小写的。</p>
<p>另外，SQL 语句中常数的书写方式是固定的，字符串常量要用单引号括起来，比如 <code>&#39;abc&#39;</code> ，日期类型的常量也要用单引号括起来，比如 <code>&#39;2015-01-27&#39;</code>，但是数字的常量直接书写即可，不需要任何标记。</p>
<h2 id="表的创建">表的创建</h2>
<p>我们以创建下面所示的商品表为例来创建所需的数据库表，这个表可以看做是某个小商店销售商品的一览表。</p>
<table>
<thead>
<tr>
<th>商品编号</th>
<th style="text-align:right">商品名称</th>
<th style="text-align:right">商品分类</th>
<th style="text-align:right">销售单价</th>
<th style="text-align:right">进货单价</th>
<th style="text-align:right">登记日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>0001</td>
<td style="text-align:right">T恤衫</td>
<td style="text-align:right">衣服</td>
<td style="text-align:right">1000</td>
<td style="text-align:right">500</td>
<td style="text-align:right">2009-09-20</td>
</tr>
<tr>
<td>0002</td>
<td style="text-align:right">打孔器</td>
<td style="text-align:right">办公用品</td>
<td style="text-align:right">500</td>
<td style="text-align:right">320</td>
<td style="text-align:right">2009-09-11</td>
</tr>
<tr>
<td>0003</td>
<td style="text-align:right">运动T恤</td>
<td style="text-align:right">衣服</td>
<td style="text-align:right">4000</td>
<td style="text-align:right">2800</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>0004</td>
<td style="text-align:right">猜到</td>
<td style="text-align:right">厨房用品</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">2800</td>
<td style="text-align:right">2009-09-20</td>
</tr>
<tr>
<td>0005</td>
<td style="text-align:right">高压锅</td>
<td style="text-align:right">厨房用品</td>
<td style="text-align:right">6800</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">2009-01-15</td>
</tr>
<tr>
<td>0006</td>
<td style="text-align:right">叉子</td>
<td style="text-align:right">厨房用品</td>
<td style="text-align:right">500</td>
<td style="text-align:right"></td>
<td style="text-align:right">2009-09-20</td>
</tr>
<tr>
<td>0007</td>
<td style="text-align:right">擦菜板</td>
<td style="text-align:right">厨房用品</td>
<td style="text-align:right">880</td>
<td style="text-align:right">790</td>
<td style="text-align:right">2008-04-28</td>
</tr>
<tr>
<td>0008</td>
<td style="text-align:right">圆珠笔</td>
<td style="text-align:right">办公用品</td>
<td style="text-align:right">100</td>
<td style="text-align:right"></td>
<td style="text-align:right">2009-11-11</td>
</tr>
</tbody>
</table>
<p>在创建表之前，需要先创建数据库，创建数据库需要使用 <code>CREATE DATABASE &lt;数据库名称&gt;</code> 语句，这里我们把数据库命名为 <code>shop</code>,则代码清单如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> shop;</span></div></pre></td></tr></table></figure>

<p>在创建数据库之后，就可以在其中创建表了，创建表的CREATE TABLE 语句的语法格式如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE &lt;表名&gt;</div><div class="line">(&lt;列名<span class="number">1</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</div><div class="line">&lt;列名<span class="number">2</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</div><div class="line">&lt;列名<span class="number">3</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</div><div class="line">&lt;列名<span class="number">4</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</div><div class="line"><span class="keyword">...</span></div><div class="line">&lt;该表的约束<span class="number">1</span>&gt; &lt;该表的约束<span class="number">2</span>&gt;,<span class="keyword">...</span></div><div class="line">);</div></pre></td></tr></table></figure>

<p>其中语句的主体要用半角符号的括弧括住，每一列可以添加约束，最后是表的约束。</p>
<p>上面的商品表的创建语句如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Product (</span></div><div class="line"> product_id  		<span class="built_in">CHAR</span>(<span class="number">4</span>)  		<span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line"> product_name 		<span class="built_in">VARCHAR</span>(<span class="number">100</span>) 	<span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line"> product_category 	<span class="built_in">VARCHAR</span>(<span class="number">32</span>)		<span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line"> selling_price		<span class="built_in">INTEGER</span>,</div><div class="line"> purchase_price		<span class="built_in">INTEGER</span>,</div><div class="line"> purchase_date		<span class="built_in">DATE</span>,</div><div class="line"> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>(product_id)</div><div class="line">);</div></pre></td></tr></table></figure>

<p>需要注意，我们只能使用半角的英文字母、数字、下划线（_）作为数据库、表和列的名称，其中出现的标点符号也要一律使用半角符号，否则会出错。</p>
<p>关于数据类型的指定，这里用到了常用的CHAR、VARCHAR、INTEGER、DATE，关于其它的数据类型在用到的时候我们再细说，此处只要能够区分CHAR 是定长字符串，VARCHAR 是可变长字符串就可以了。另外Oracle 的DATE 类型除了年月日以外，还包括时分秒，这里我们只用到了日期部分。</p>
<p>最后我们把 <code>product_id</code> 设置为表的主键，即 <code>product_id</code> 中的内容是不能重复的，可以根据该字段（列名）唯一确定一行记录。</p>
<h2 id="表的删除">表的删除</h2>
<p>删除表的语句非常简单，只需要一行 <code>DROP TABLE &lt;表名&gt;</code> 就可以了，如果想要删除上面我们创建的表 <code>Product</code>，只需要执行下面的语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Product;</span></div></pre></td></tr></table></figure>

<p>但是我们不推荐删除业务表，因为恢复起来会很麻烦，尤其是存储了大量数据的表！</p>
<h2 id="表的更新">表的更新</h2>
<p>表的更新有两种含义，一种指的是表结构的变化，具体来说就是字段的增加、删除和字段名称的修改，另外一种指的是表中数据的增加、删除和修改，下面我们逐一进行介绍（主要以MySQL 为例）。</p>
<p><strong>表结构的更新</strong> </p>
<p>在向表中添加一列，即添加一个新的字段时，使用 <code>ALTER TABLE</code> 语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> &lt;列名&gt;;</span></div></pre></td></tr></table></figure>

<p>删除表中的某一列可以使用下面的 <code>ALTER TABLE</code> 语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> &lt;列名&gt;;</span></div></pre></td></tr></table></figure>

<p>删除表中的列和删除表一样，执行之后可以看做是无法恢复的，删除表中的列之后，就只能重新创建字段了。</p>
<p>当我们想给表中的某一个字段重新命名时，可以使用下面的语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> <span class="keyword">COLUMN</span> &lt;列名<span class="number">1</span>&gt; <span class="keyword">TO</span> &lt;列名<span class="number">2</span>&gt;;</span></div></pre></td></tr></table></figure>

<p>在更新表结构时，Oracle 和SQL Server 有特定的语法需要注意</p>
<blockquote>
<ul>
<li><strong>使用Oracle 和SQL Server 时不用写COLUMN</strong></li>
<li><strong>在Oracle 中添加多列时可以使用括弧：</strong> <code>ALTER TABLE &lt;表名&gt; ADD (&lt;列名1&gt;,&lt;列名2&gt;,...);</code></li>
</ul>
</blockquote>
<p><strong>表数据的更新</strong></p>
<p>向表 <code>Product</code> 中插入数据的代码如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span></div><div class="line"></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0001'</span>,<span class="string">'T恤衫'</span>,<span class="string">'衣服'</span>,<span class="number">1000</span>,<span class="number">500</span>,<span class="string">'2009-09-20'</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0002'</span>,<span class="string">'打孔器'</span>,<span class="string">'办公用品'</span>,<span class="number">500</span>,<span class="number">320</span>,<span class="string">'2009-09-11'</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0003'</span>,<span class="string">'运动T恤'</span>,<span class="string">'衣服'</span>,<span class="number">4000</span>,<span class="number">2800</span>,<span class="literal">NULL</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0004'</span>,<span class="string">'菜刀'</span>,<span class="string">'厨房用品'</span>,<span class="number">3000</span>,<span class="number">2800</span>,<span class="string">'2009-09-20'</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0005'</span>,<span class="string">'高压锅'</span>,<span class="string">'厨房用品'</span>,<span class="number">6800</span>,<span class="number">5000</span>,<span class="string">'2009-01-15'</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0006'</span>,<span class="string">'叉子'</span>,<span class="string">'厨房用品'</span>,<span class="number">500</span>,<span class="literal">NULL</span>,<span class="string">'2009-09-20'</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0007'</span>,<span class="string">'擦菜板'</span>,<span class="string">'厨房用品'</span>,<span class="number">880</span>,<span class="number">790</span>,<span class="string">'2008-04-28'</span>);</span></div><div class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Product <span class="keyword">VALUES</span> (<span class="string">'0008'</span>,<span class="string">'圆珠笔'</span>,<span class="string">'办公用品'</span>,<span class="number">100</span>,<span class="literal">NULL</span>,<span class="string">'2009-11-11'</span>);</span></div><div class="line"></div><div class="line"><span class="operator"><span class="keyword">COMMIT</span>;</span></div></pre></td></tr></table></figure>



<p>使用插入行的指令语句是 <code>INSERT</code>，开头的 <code>START TRANSACTION;</code> 是开始插入行的指令语句，<code>COMMIT;</code> 则是确定行插入的指令语句。</p>
<p>开始插入行的指令语句中，不同的RDBMS 略有不同</p>
<blockquote>
<ul>
<li><strong>Oracle 和DB2 中，无需使用 <code>START TRANSACTION</code> 语句</strong></li>
<li><strong>SQL Server 和 PostgreSQL 则要使用 <code>BEGIN TRANSACTION</code> 语句</strong></li>
</ul>
</blockquote>
<p>修改表中符合要求的记录的值，需要用到SQL 查询，SQL 查询是SQL 语法中最重要的部分，我们之后会详细讲解，这里我们只是列出修改记录值的通用语法规则，复杂的查询语句可能还会用到表别名。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UPDATE &lt;表名&gt; SET <span class="string">'列名1'</span> = <span class="string">'xxx'</span> WHERE <span class="keyword">...</span>;</div></pre></td></tr></table></figure>

<p>选择性地删除表中的一些记录（行）也会用到SQL 查询，它的语法如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE * FROM &lt;表名&gt; WHERE <span class="keyword">...</span>;</div></pre></td></tr></table></figure>

<p><strong>表名的变更</strong></p>
<p>有时候我们在创建一个表并使用一段时间之后，可能会觉得表名不是很合适，需要修改，那么怎么办呢？</p>
<p>可以使用 <code>RENAME</code> 指令来解决这样的问题，但是不同的数据库使用时略有差异。</p>
<blockquote>
<ul>
<li><strong>Oracle,PostgreSQL: <code>ALTER TABLE Product RENAME TO Item;</code></strong></li>
<li><strong>DB2:                 <code>RENAME TABLE Product TO Item;</code></strong></li>
<li><strong>SQL Server:               <code>sp_rename &#39;Product&#39; , &#39;Item&#39;;</code></strong></li>
<li><strong>Mysql:                   <code>RENAME TABLE Product TO Item;</code></strong></li>
</ul>
</blockquote>
<h2 id="实际操作">实际操作</h2>
<p>针对上面的内容，我们以Windows 下的Mysql5.5 为例进行具体操作，步骤如下</p>
<p>Step 1：打开CMD 命令窗口，执行 <code>net start mysql</code> 开启MySQL 服务；</p>
<p><img src="http://zhang1g.qiniudn.com/net-start-mysql.PNG" alt="开启Mysql 服务"></p>
<p>Step 2：打开Mysql 命令行客户端，输入密码，执行下面的指令，注意需要使用 <code>use &lt;数据库名&gt;;</code> 来切换数据库。</p>
<p><img src="http://zhang1g.qiniudn.com/create-table-shop.PNG" alt="创建数据库shop 以及表Product"></p>
<p><img src="http://zhang1g.qiniudn.com/insert-data-to-table-shop.PNG" alt="向表Product 中插入数据"></p>
<p>插入数据后我们通过Mysql Administrator 之类的带界面的Mysql 客户端查看我们的结果，很可惜地发现插入的汉字显示为乱码</p>
<p><img src="http://zhang1g.qiniudn.com/inser-data-to-shop-error-code.PNG" alt="插入的汉字显示为乱码"></p>
<p>这里我们先不做处理，在该系列博客的番外篇<a href="http://zhangyigong.github.com/2015/01/27/solve-mysql-messy-code" target="_blank" rel="external">SQL基础（番外篇）解决Mysql 的中文乱码问题</a>中，我们会详细讲述Mysql 产生中文乱码的前因后果以及解决方法。</p>
<h2 id="总结">总结</h2>
<p>这一片博客中我们简单介绍了一下为什么要使用数据库来管理数据，根据SQL 语句的类型将SQL 语句分为 DDL、DML、DCL 三类，并且对除了SQL 查询以外的其他语法做了简单的介绍，包括</p>
<ul>
<li>数据库和表的建立</li>
<li>表的删除</li>
<li>表结构的更新</li>
<li>表数据的插入和更新</li>
</ul>
<p>在下一篇<a href="http://zhangyigong.github.com/2015/01/27/sql-query-base-learn/" target="_blank" rel="external">SQL 基础（二）SQL 查询基础</a>我们会介绍SQL 查询相关的基础内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>总是感觉之前学的数据库相关的知识很零散，不够系统，加之好久没有看关于SQL 的知识，不免有点生疏了，于是想找一本合适的教材回顾一下。后来找到了一本可以堪称是零基础入门的SQL 书籍，这里给大家推荐一下：</p>
<p>《SQL 基础教程》 【日】MICK 著    孙淼 罗勇 译 </p>
<p>书中的SQL 都是基于标准SQL 2003编写，并且关于几个常用的RDBMS 在使用SQL 时的区别叙述的很详细，行文也很流畅，只是书中的命名都是按日文来的，不过影响不是很大。书中使用的RDBMS 是PostgreSQL，但是由于在实际中我使用Mysql 较多，所以我会主要侧重于Mysql 的相关部分。</p>
<p>下面就开始我们的SQL 之旅了。</p>
<h2 id="数据库是什么">数据库是什么</h2>
<p>很多人可能会觉得我们在使用计算机管理数据的时候，使用文本文件或者Excel 之类的电子表格软件不就可以了吗？为什么非要使用DBMS 这样专门的系统来管理数据呢？</p>
]]>
    
    </summary>
    
      <category term="sql" scheme="http://zhangyigong.github.com/tags/sql/"/>
    
      <category term="数据库" scheme="http://zhangyigong.github.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="读书" scheme="http://zhangyigong.github.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Github Pages 搭建独立博客的后续过程]]></title>
    <link href="http://zhangyigong.github.com/2015/01/20/follow-up-process-of-bulid-blog/"/>
    <id>http://zhangyigong.github.com/2015/01/20/follow-up-process-of-bulid-blog/</id>
    <published>2015-01-20T04:47:08.000Z</published>
    <updated>2015-03-09T02:17:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="内容回顾">内容回顾</h2>
<p>在<a href="http://zhangyigong.github.io/2015/01/13/bulid-blog-with-githubpages-and-hexo/" target="_blank" rel="external">使用Github Pages 和Hexo 搭建独立博客</a>一文中，我们逐步讲解了如何搭建一个自己的独立博客，包括环境的安装和配置，博客主题的选择和修改，添加RSS 订阅和第三方系统等等。</p>
<p>关于之前的内容，还有一篇很不错的文章<a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo在github上构建免费的Web应用</a>，说的比较齐全，评论里面也有一些常见问题的解决方法，这里就不一一列举了。</p>
<p>但是到目前为止，要成为一个真正意义上的独立博客，我们还有一些工作需要做，下面就是关于后续工作的一些记录。</p>
<h2 id="域名申请">域名申请</h2>
<p>在很多地方都可以购买域名，比如说<a href="https://www.namecheap.com/" target="_blank" rel="external">NAMECHEAP</a> 还有<a href="http://www.namesilo.com/" target="_blank" rel="external">NAMESILO</a>，我是从<a href="https://www.godaddy.com/" target="_blank" rel="external">GODADDY</a> 上购买的这个域名，主要是因为它支持支付宝支付，支付比较方便。</p>
<a id="more"></a>

<p><img src="http://zhang1g.qiniudn.com/godaddy-logo.jpg" alt="从Godday 上购买域名"></p>
<p>网上有很多在Godday 上购买域名的教程，但是随着Godday 网站的改版，有一些教程已经不适用了，这里我列出一些针对新版的购买教程。</p>
<p><a href="http://www.admin5.com/article/20131014/527495.shtml" target="_blank" rel="external">2013年10月新版godaddy域名注册图文教程</a></p>
<p><a href="http://xianhuo.org/godaddy-yumingzhuce-xinban.html" target="_blank" rel="external">GODADDY域名注册教程 新版</a></p>
<p>另外，在购买域名时可以使用优惠码，能省掉一些钱，优惠码在网上搜有很多，想要的可以自己找一下。使用优惠码后没有优惠或者没有出现支付宝支付的选项，可以尝试清除浏览器cookies 再进行尝试。付款之后记得在自己的注册邮箱中查看激活邮件，并点击激活链接激活域名。</p>
<h2 id="域名解析">域名解析</h2>
<p>申请域名后，域名解析的工作可以登陆Godday 官网并进行操作，但是由于Godday 没有中文站，所以操作起来会有一些不方便。具体的Godday 域名解析教程可以参考</p>
<p><a href="http://jingyan.baidu.com/article/47a29f243a511bc014239920.html" target="_blank" rel="external">2013新版godaddy域名解析教程</a></p>
<p><a href="http://godaddy.idcspy.com/dns" target="_blank" rel="external">2014年最新Godaddy域名解析教程</a></p>
<p>我使用的是<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a> 进行的域名解析，要比在Godday 官网上稍微简单一些，下面是具体的操作步骤。</p>
<p><strong>修改Godday 的Nameservers</strong></p>
<p>首先需要在Godday 官网上修改DNS 地址，更改Godaddy 的Nameservers 为DNSpod 的NameServers。</p>
<ol>
<li>到Godaddy 首页登录，输入用户名和密码，然后点击 <code>Login In</code> 登录</li>
<li>登录成功之后，点击右面的 <code>My Account</code> 进入到Godaddy 的账户概述页面</li>
<li>点击右面的 <code>Domain Manager</code> 进入到Godaddy 的域名管理界面</li>
<li>点击需要进行管理操作的域名进入单个域名的管理界面，点击上部的 <code>Nameservers</code> ,出现下拉菜单，然后选择 <code>Set Nameservers</code> 来管理Name Server 记录</li>
<li>选择 <code>I have specific nameservers for my domains</code> , 在这里可以把我们在其它域名解析服务提供商提供的NS地址，如DNSPod。填好之后点击”OK”继续</li>
<li>到此修改NS记录就已经成功了，现在就可以到第三方的界面去管理DNS记录了，比如添加A记录等等。</li>
</ol>
<p><img src="http://zhang1g.qiniudn.com/update-dns-servers.png" alt="修改Godday 的Nameservers"></p>
<p><strong>使用DNSPod 进行域名解析</strong></p>
<p>修改完毕之后，登录DNSPod，导入新申请的域名，修改A 记录，指向Github Pages 服务对应的主机IP。修改www CNAME 对应的记录是为Github 注册的仓库，也就是之前我们访问博客所使用的Github 二级域名。设置成功后如下所示</p>
<p><img src="http://zhang1g.qiniudn.com/dnspod-set.PNG" alt="使用DNSpod 进行域名绑定"></p>
<p>如博客不能登录，或者博客更新发布不成功，有可能是Github 更改了空间服务的IP 地址，记得及时到在GitHub Pages 查看最新的IP。关于这一点详细内容，在文章的最后我会提到。</p>
<p>关于使用DNSPod 的其他内容可以参考<a href="https://support.dnspod.cn/Kb/showarticle/tsid/42/" target="_blank" rel="external">DNSPod提供的官方帮助文档</a>，其中包含了一些常见的问题。</p>
<p><strong>在Github Pages 中设置CNAME</strong></p>
<p>在Repository的根目录下面，新建一个名为CNAME 的文本文件，里面写入要绑定的域名，比如 <code>zhang1g.info</code> 。对应到我们搭建的个人博客，就是 <code>HexoBlog</code> 文件夹下的 <code>source</code> 文件夹。</p>
<p>添加之后，使用hexo 命令将博客系统重新发布到Github 上，就可以使用新注册的域名访问自己的博客了。</p>
<h2 id="添加站点地图">添加站点地图</h2>
<p>到目前为止，我们的博客还没有被别人访问产生流量，接下来我们需要添加网站的站点地图，并把网站提交到百度收录，这样才能够通过搜索引擎搜到我们的博客。</p>
<p>使用Hexo 添加站点地图非常简单，在 <code>HexoBlog</code> 文件夹下，找到 <code>_config.yml</code> 文件，在其中添加内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="label">theme:</span> yilia</div><div class="line"><span class="label">exclude_generator:</span></div><div class="line"><span class="label">plugins:</span></div><div class="line">- hexo-generator-feed</div><div class="line">- hexo-generator-sitemap</div><div class="line"></div><div class="line"><span class="preprocessor">#sitemap</span></div><div class="line"><span class="label">sitemap:</span></div><div class="line">  path: sitemap.xml</div></pre></td></tr></table></figure>

<p>我们曾经使用同样的方法添加过RSS 插件。</p>
<p>之后打开Git Bash，输入下面的命令安装插件即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span> hexo-generator-sitemap</span></div></pre></td></tr></table></figure>

<p>经过上述工作，站点地图就已经生成了，我们可以执行命令 <code>hexo g</code> 和 <code>hexo s</code> 并在浏览器中输入 <code>http://localhost:4000/sitemap.xml</code> 来进行测试。</p>
<p>在下一次发布更新到Github 上时，相应的站点地图也会更新。</p>
<p>在生成站点地图之后，我们需要把网站提交到百度进行收录。我们需要以下工具</p>
<ul>
<li>百度账号</li>
<li>百度站长平台</li>
</ul>
<p>用百度账号登陆<a href="http://zhanzhang.baidu.com/site/index" target="_blank" rel="external">百度站长平台</a>，并添加站点，站点的URL 就是我们申请的域名，添加成功后需要验证网站</p>
<p><img src="http://zhang1g.qiniudn.com/verify-blogsite.PNG" alt="百度站长工具验证网站"></p>
<p>这里我们选择 <code>文件验证</code> 方式，将下载的文件放到 <code>HexoBlog</code> 下的 <code>public</code> 文件夹内，打开Git Bash 执行命令 <code>hexo d</code>，更新Github 上的内容，稍等片刻就能通过浏览器访问验证文件的内容，此时点击完成验证即可。</p>
<p>添加网站之后选择 <code>网站分析</code> 下的 <code>抓取诊断</code>，输入URL，进行诊断</p>
<p><img src="http://zhang1g.qiniudn.com/zhuaqu-zhenduan.PNG" alt="百度站长工具抓取诊断"></p>
<p>诊断没有问题之后选择 <code>数据提交</code> 下的 <code>URL提交</code> ，输入域名，点击提交按钮，一段时间之后，我们的博客就能够被百度搜索到了。</p>
<h2 id="搭建博客时出现的一点小问题">搭建博客时出现的一点小问题</h2>
<p>在使用Github Pages 搭建完成博客之后，有一段时间使用 <code>hexo d</code> 将博客内容更新到Github 上，但是访问博客一直显示的是旧的内容，我很奇怪，后来查看了注册邮箱，发现收到了Github 发送的标题为 <code>Page build failure</code> 的邮件，内容如下</p>
<p><img src="http://zhang1g.qiniudn.com/page-bulid-failure-email.PNG" alt="Page bulid failure邮件内容"></p>
<p>大意是说页面站点指向了一个过时的IP 地址，关于这部分可以按照邮件提供的链接地址查看详细信息。后来在DNSPod 上修改了A 记录对应的IP 地址，之后就一切正常了，目前Github Pages 提供的IP 地址是 <code>192.30.252.153</code>。下面是邮件中给出的两个链接。</p>
<p><a href="https://github.com/blog/1917-github-pages-legacy-ip-deprecation" target="_blank" rel="external">GitHub Pages Legacy IP Deprecation</a></p>
<p><a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/" target="_blank" rel="external">Setting up a custom domain with GitHub Pages</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="内容回顾">内容回顾</h2>
<p>在<a href="http://zhangyigong.github.io/2015/01/13/bulid-blog-with-githubpages-and-hexo/" target="_blank" rel="external">使用Github Pages 和Hexo 搭建独立博客</a>一文中，我们逐步讲解了如何搭建一个自己的独立博客，包括环境的安装和配置，博客主题的选择和修改，添加RSS 订阅和第三方系统等等。</p>
<p>关于之前的内容，还有一篇很不错的文章<a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo在github上构建免费的Web应用</a>，说的比较齐全，评论里面也有一些常见问题的解决方法，这里就不一一列举了。</p>
<p>但是到目前为止，要成为一个真正意义上的独立博客，我们还有一些工作需要做，下面就是关于后续工作的一些记录。</p>
<h2 id="域名申请">域名申请</h2>
<p>在很多地方都可以购买域名，比如说<a href="https://www.namecheap.com/" target="_blank" rel="external">NAMECHEAP</a> 还有<a href="http://www.namesilo.com/" target="_blank" rel="external">NAMESILO</a>，我是从<a href="https://www.godaddy.com/" target="_blank" rel="external">GODADDY</a> 上购买的这个域名，主要是因为它支持支付宝支付，支付比较方便。</p>
]]>
    
    </summary>
    
      <category term="blog" scheme="http://zhangyigong.github.com/tags/blog/"/>
    
      <category term="github" scheme="http://zhangyigong.github.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[漫谈验证码（三） 验证码的奇思妙用]]></title>
    <link href="http://zhangyigong.github.com/2015/01/19/wonderful-use-of-verification-code/"/>
    <id>http://zhangyigong.github.com/2015/01/19/wonderful-use-of-verification-code/</id>
    <published>2015-01-19T12:13:43.000Z</published>
    <updated>2015-03-09T02:22:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="验证码的起源">验证码的起源</h2>
<p>在刚开始有Internet 的时候，是没有验证码这种东西的，但是这导致了杯具的发生，垃圾评论和垃圾邮件可以轻松通过任何一个网站的注册程序，通过各种方式轰炸人民群众的眼球。</p>
<p>最先想要解决这一问题的是<strong>雅虎</strong>，作为互联网时代早期最重要的免费邮件提供商，他们一方面要解决用户们每天遇到的数以百计的垃圾邮件轰炸，另一方面，他们自己的免费邮箱，恰恰又是垃圾邮件的最爱，因为耗费无数资源所阻止的垃圾邮件，都来自于自己的服务器。这让雅虎开始认真考虑如何解决人机辨识问题。</p>
<p>于是他们找到了一位当时刚刚21岁的天才Luis von Ahn。 而Luis Von Ahn 给出的方案，就是这个让人民群众微微皱眉，但是让计算机耸肩挠头的验证码。</p>
<p>当时计算机辨识技术还很落后，对于经过扭曲、污染的文字，无法辨识。而人类却可以轻松认出这些文字。</p>
<p>这是一个简单而巧妙的设计，计算机先是产生一个随机的字符串，然后用程序把这个字符串的图像进行随机的污染，扭曲，再显示给显示器前的人或者机器。凡是能够辨识这些字符的，即为人类。</p>
<a id="more"></a>

<p><img src="http://zhang1g.qiniudn.com/Luis-von-Ahn.jpeg" alt="验证码的发明人Luis von Ahn"></p>
<h2 id="验证码的发展">验证码的发展</h2>
<p>当全世界数以十亿计的人每天都会浪费几秒钟的时间参与辨认文字这一简单活动的时候，你是否有想过，这其中浪费的人脑智力是否能得到更好的应用呢？</p>
<p>Luis Von Ahn 也在思考这个问题，他最终的设计是：<strong>让人们用这些脑力解决一些计算机无法解决的图书数字化</strong>。</p>
<p>在计算机时代以前，印刷术已经存在了数百年，但这些印刷术所产生的书本和报纸等等，对于计算机来说都是模拟信号，仅以图像的形式存在，而非以数字化的形式存在。但是，早期的印刷术并不精确，文字大小不一，形象有差别。而且因为印刷品年代久远，拥有各种细微的缺损和污染。这对人眼来说不是什么大问题，但对计算机来说就麻烦了。</p>
<p>目前在google、yahoo、youtube 等各个网站都能看到的双capcha，一个是需要辨认的文档图像，一个是计算机生成的capcha。</p>
<p><img src="http://zhang1g.qiniudn.com/doubble-verify-code.jpg" alt="双验证码的广泛使用"></p>
<p>2002年，luis Von Ahn 开始让验证码引用各种无法被计算机辨识的文字图像，目前，已经有上万网站采用他的新一代Capcha，每天帮助辨识数以百万计的古老文档。</p>
<p>但是这里有一个问题，对于最初的验证码来说，计算机实际上是知道答案的。而Luis 希望人们辨识的文字，计算机是不知道答案的，那如何能验证返回的答案到底是不是真的呢？</p>
<p>解决这个问题的方法依然体现了Luis 一贯的简洁和优美，他让人们每次辨识两个，而非一个Capcha，其中一个来自于计算机随机生成的字符串，而另一个则是从文档中选取的计算机不认识的字符图像。只要人们对前一个字符串给出的答案是正确的，那么就判定，人们对后一个Capcha 的辨识是正确的。</p>
<p>用这一方法，luis 的Capcha2.0 已经帮助完成了整个纽约时报130 年的报纸存档数字化——这一本可能花费无数时间和资源的工程，在几个月之内就由各位网友们完成了。</p>
<h2 id="验证码的奇思妙用">验证码的奇思妙用</h2>
<p>现在，我们仍然能看到有很多和验证码相关的奇思妙用。其中有些是用来创业的，另一些则试图为社会谋福祉。创业者们将广告融入到验证码中，尽管方式不同，但基本原理都是通过用户关注和输入广告上的特殊文字进行宣传。为社会谋福祉的形式则不尽相同，最著名的就是我们之前提到的用来识别英文古籍扫描件的reCAPTCHA 服务。</p>
<p>无论哪种目的、哪种方式，将分散的人类识别普通验证码的劳动加以整合利用是一件对人类有益的事。有人对于验证码应用提出了如下几点设想：</p>
<p><strong>单问题调查问卷</strong></p>
<p>以问卷中一个问题有2个选项为例，可以通过在两个选项中都随机选择一部分文字作为用户需要输入的验证关键字，用户输入哪个选项的都可以，这种选择就代表了其对相应选项的选择。</p>
<p><strong>识别手工填写的单据中的单据号</strong></p>
<p>目前还有很多组织在使用手工填写的单据，然而如何管理这些单据却成了一个大问题，特别是在单据数量十分巨大时，查找一张旧单据可能耗费很大功夫。</p>
<p>这时候人们会自然而然地想到用计算机来管理，然而计算机必须得知道单据的单据号才能对其进行有效的管理和检索，因此识别手写单据号成为了阻碍这一进程的大问题。因此可以效仿reCAPTCHA 的服务方式，借助网民的力量来识别大量计算机难以识别的单据号。</p>
<p><strong>“网络打码”工</strong></p>
<p>有一些人把验证码通过某些技术转移到一个自制的打码软件上，一个闲着无聊的网络打码工，就下载这个小程序； 这边机器自动注册，出来的验证码，就由这些打码工不停的输入弹出的验证码，然后传输到自动注册机器，完成验证，注册（购买）成功。这也是手工破解验证码常见的一种方式。</p>
<p><img src="http://zhang1g.qiniudn.com/verify-code-person.jpg" alt="人工打码破解验证码工具"></p>
<p><strong>利用验证码进行广告盈利</strong></p>
<p>随着验证码的发展，验证码也带来了更多的可能性，比如通过广告盈利的机遇，下面这则验证码示范了利用验证码展示广告。但遗憾的是由于其不具有规模性，仍受到穷举攻击的威胁。</p>
<p><img src="http://zhang1g.qiniudn.com/verify-code-ad.png" alt="广告验证码"></p>
<p>不知道关于验证码，大家还有什么其他的想法呢？</p>
<h2 id="验证码的未来">验证码的未来</h2>
<p>较早前就有报道指出， Google 正在测试一种新的验证码技术，这种验证码技术不像传统验证码系统要求输入文字，而是要求用户将图形旋转到正确的方向。</p>
<p>比较常见的还有另外一种基于图像的验证码，如下所示</p>
<p><img src="http://zhang1g.qiniudn.com/verify-code-picture.jpg" alt="基于图像的验证码"></p>
<p>当然，验证码还可以走的更远，假如用户有视力障碍，他应该可以选择通过聆听验证码音频的方式完成验证，等等。</p>
<p>关于验证码还有一些有意思的内容，大家可以参考文章<a href="http://www.36kr.com/p/119746.html" target="_blank" rel="external">请证明你是人：验证码输入的游戏化</a>,以及另外一篇<a href="http://www.36kr.com/p/95295.html" target="_blank" rel="external">继古籍文字后，Google利用reCAPTCHA验证码技术识别Google街景的街道地址和名称</a>。</p>
<h2 id="总结">总结</h2>
<p>验证码技术是一种计算机技术发展下的矛盾产物，人类渴望计算机能够通过自动化的过程完成更多的任务，却同样要防止计算机被利用在破坏与恶意的用途当中。随着人工智能领域的研究成果越来越先进，计算机将变得越来越通情达理，不知道是不是会有一天计算机能够通过验证码验证，那时候我们又该如何区分人类和计算机呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="验证码的起源">验证码的起源</h2>
<p>在刚开始有Internet 的时候，是没有验证码这种东西的，但是这导致了杯具的发生，垃圾评论和垃圾邮件可以轻松通过任何一个网站的注册程序，通过各种方式轰炸人民群众的眼球。</p>
<p>最先想要解决这一问题的是<strong>雅虎</strong>，作为互联网时代早期最重要的免费邮件提供商，他们一方面要解决用户们每天遇到的数以百计的垃圾邮件轰炸，另一方面，他们自己的免费邮箱，恰恰又是垃圾邮件的最爱，因为耗费无数资源所阻止的垃圾邮件，都来自于自己的服务器。这让雅虎开始认真考虑如何解决人机辨识问题。</p>
<p>于是他们找到了一位当时刚刚21岁的天才Luis von Ahn。 而Luis Von Ahn 给出的方案，就是这个让人民群众微微皱眉，但是让计算机耸肩挠头的验证码。</p>
<p>当时计算机辨识技术还很落后，对于经过扭曲、污染的文字，无法辨识。而人类却可以轻松认出这些文字。</p>
<p>这是一个简单而巧妙的设计，计算机先是产生一个随机的字符串，然后用程序把这个字符串的图像进行随机的污染，扭曲，再显示给显示器前的人或者机器。凡是能够辨识这些字符的，即为人类。</p>
]]>
    
    </summary>
    
      <category term="感悟杂谈" scheme="http://zhangyigong.github.com/tags/%E6%84%9F%E6%82%9F%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[漫谈验证码（二） 使用开源组件生成验证码]]></title>
    <link href="http://zhangyigong.github.com/2015/01/17/verification-code-generate-by-opensource-component/"/>
    <id>http://zhangyigong.github.com/2015/01/17/verification-code-generate-by-opensource-component/</id>
    <published>2015-01-17T08:53:28.000Z</published>
    <updated>2015-03-09T02:20:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开源组件简介">开源组件简介</h2>
<p>在<a href="http://zhangyigong.github.io/2015/01/16/verification-code-generated-by-java-servlet/" target="_blank" rel="external">漫谈验证码（一） 使用Servlet 生成验证码</a>一文中，我们介绍了使用Servlet 生成验证码的方法。但是生成的验证码图片比较简单，使用图像识别的方法还是很容易破解，因此我们在实际应用中希望能够生成比较复杂的验证码图片，比如汉字、算式等，并且添加一些干扰。</p>
<p>使用一些相关的开源组件可以很容易的实现上述功能。常见的开源组件包括Kaptcha、jCaptcha 和Simplecaptcha。</p>
<p>SimpleCaptcha 是很棒的项目，但是，SimpleCaptcha 似乎没有被维护和更新，在JDK1.5 和Servlet 输出的HTTP 头部情况下还存在一些问题，有一堆的错误报告。 近几年，SimpleCaptcha 的论坛没有任何的消息，也没有新的版本或任何改变。 </p>
<p>jCaptcha 是很多Java 开发者使用的验证码组件，但是默认的配置相对有点恶心，它是一个很棒的项目，但绝对不是一个快速解决方案，更像是一个库。在网站上，它默认输出的样式不是太难分辨就是不够好，也相当的慢。</p>
<p>肯定的是，你需要花很多的时间来熟悉它的API。但事实是，我愿意是一个简单的jar 包文件，轻松地导入我的项目，然后在web.xml 添加几行代码即可。 </p>
<p>因此，这里推荐一个非常简单的验证码组件：<strong>Kaptcha</strong>。 </p>
<a id="more"></a>

<p>Kaptcha 很容易安装使用，并且默认输出验证码。默认产生的验证码和放在这篇博客最前面的验证码图片很相似。如果你想改变输出的样式，可以通过配置一组选项，就可以输出自定义的变形样式。</p>
<p>接下来我们将使用Kaptcha 开源组件来生成不同格式的复杂的验证码图片。</p>
<h2 id="Kaptcha_组件生成复杂验证码">Kaptcha 组件生成复杂验证码</h2>
<p>在Web 项目中使用Kaptcha 组件非常简便，只需要以下几个步骤即可，其中最复杂的是配置相应的web.xml 文件。</p>
<ol>
<li>下载Kaptcha-2.x.jar</li>
<li>将jar 包导入项目</li>
<li>编写页面</li>
<li>配置web.xml </li>
<li>启动项目</li>
</ol>
<p>在配置web.xml 时，添加Kaptcha 组件对应的Servlet 配置项是必须的，Kaptcha 组件的其他配置项也都是在web.xml 中进行，稍后会进行介绍。最核心的配置如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></div><div class="line">		com.google.code.kaptcha.servlet.KaptchaServlet</div><div class="line">	<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></div></pre></td></tr></table></figure>

<p>下面我们就逐步开始使用Kaptcha 来生成不同类型的复杂验证码图片，包括字母数字混合、汉字、算式等，并增加不同类型的干扰效果。</p>
<p><strong>默认验证码的生成</strong></p>
<p>新建一个名为KaptchaVerifyCode 的Java Web 项目，右键点击项目工程，在属性中修改项目的默认编码格式为UTF-8。</p>
<p>在<a href="http://code.google.com/p/kaptcha/downloads/list" target="_blank" rel="external">官网</a>下载Kaptcha 组件的jar 包，或者在百度云搜索下载，我下载使用的是<a href="http://pan.baidu.com/share/link?shareid=161907&amp;uk=3927561956" target="_blank" rel="external">kaptcha-2.3.2.jar</a>。</p>
<p>将jar 包导入到项目的WEB-INFO/lib 目录下，并添加JSTL 支持（将jstl.jar 和standard.jar 也添加到项目的WEB-INFO/lib 目录中，并在JSP 页面中添加语句 <code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;</code> ）。</p>
<p>在web.xml 中配置Kaptcha 组件相关的servlet 和servlet-mapping，具体如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></div><div class="line">		com.google.code.kaptcha.servlet.KaptchaServlet</div><div class="line">	<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/KaptchaVerifyCode.jpg<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>

<p>在index.jsp 页面中添加验证码图片显示的HTML 代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">alt</span>=<span class="value">"验证码"</span> <span class="attribute">src</span>=<span class="value">"KaptchaVerifyCode.jpg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div></pre></td></tr></table></figure>

<p>开启tomcat 服务器，在浏览器中输入 <code>http://localhost:8080/KaptchaVerifyCode/</code> 即可看到Kaptcha 组件默认生成的验证码图片。</p>
<p><img src="http://zhang1g.qiniudn.com/kaptcha-verify-code2.PNG" alt="Kaptcha 组件生成验证码默认效果"></p>
<p><strong>Kaptcha 组件的详细配置</strong></p>
<p>Kaptcha 所有的参数都有默认的配置，如果我们不显式配置的话，会采取默认的配置。<br>如果要显式配置Kaptcha ，在配置Kaptcha 对应的Servlet 时，在init-param 增加相应的参数即可。</p>
<p>全部详细的参数配置可以参考<a href="http://code.google.com/p/kaptcha/wiki/ConfigParameters" target="_blank" rel="external">官网Kaptcha 参数配置详细信息</a>，如果打开比较慢也可以参考<a href="http://www.360doc.com/content/12/0224/04/1542811_189166409.shtml" target="_blank" rel="external">360doc-Google kaptcha配置属性表</a>。</p>
<p>下面列出了常见的参数配置类型</p>
<ul>
<li>验证码的字体 </li>
<li>验证码字体的大小 </li>
<li>验证码字体的字体颜色 </li>
<li>验证码内容的范围(数字，字母，中文汉字！) </li>
<li>验证码图片的大小，边框，边框粗细，边框颜色 </li>
<li>验证码的干扰线(可以自己继承 <code>com.google.code.kaptcha.NoiseProducer</code> 写一个自定义的干扰线) </li>
<li>验证码的样式(鱼眼样式、3D、普通模糊……)</li>
</ul>
<p>详细信息如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">kaptcha.border  是否有边框  默认为<span class="constant">true</span>  我们可以自己设置yes，no</div><div class="line">kaptcha.border.color   边框颜色   默认为Color.BLACK</div><div class="line">kaptcha.border.thickness  边框粗细度  默认为<span class="number">1</span></div><div class="line">kaptcha.producer.impl   验证码生成器  默认为DefaultKaptcha</div><div class="line">kaptcha.textproducer.impl   验证码文本生成器  默认为DefaultTextCreator</div><div class="line">kaptcha.textproducer.<span class="keyword">char</span>.<span class="keyword">string</span>   验证码文本字符内容范围  </div><div class="line">                                   默认为abcde2345678gfynmnpwx</div><div class="line">kaptcha.textproducer.<span class="keyword">char</span>.<span class="built_in">length</span>   验证码文本字符长度  默认为<span class="number">5</span></div><div class="line">kaptcha.textproducer.font.names    验证码文本字体样式  </div><div class="line">                                   默认为<span class="built_in">new</span> Font(<span class="string">"Arial"</span>, <span class="number">1</span>, fontSize), </div><div class="line">                                   <span class="built_in">new</span> Font(<span class="string">"Courier"</span>, <span class="number">1</span>, fontSize)</div><div class="line">kaptcha.textproducer.font.size   验证码文本字符大小  默认为<span class="number">40</span></div><div class="line">kaptcha.textproducer.font.color  验证码文本字符颜色  默认为Color.BLACK</div><div class="line">kaptcha.textproducer.<span class="keyword">char</span>.<span class="constant">space</span>  验证码文本字符间距  默认为<span class="number">2</span></div><div class="line">kaptcha.noise.impl    验证码噪点生成对象  默认为DefaultNoise</div><div class="line">kaptcha.noise.color   验证码噪点颜色   默认为Color.BLACK</div><div class="line">kaptcha.obscurificator.impl   验证码样式引擎  默认为WaterRipple</div><div class="line">kaptcha.<span class="built_in">word</span>.impl   验证码文本字符渲染   默认为DefaultWordRenderer</div><div class="line">kaptcha.background.impl   验证码背景生成器   默认为DefaultBackground</div><div class="line">kaptcha.background.<span class="built_in">clear</span>.<span class="built_in">from</span>   验证码背景颜色渐进   默认为Color.LIGHT_GRAY</div><div class="line">kaptcha.background.<span class="built_in">clear</span>.<span class="built_in">to</span>   验证码背景颜色渐进   默认为Color.WHITE</div><div class="line">kaptcha.image.width   验证码图片宽度  默认为<span class="number">200</span></div><div class="line">kaptcha.image.height  验证码图片高度  默认为<span class="number">50</span></div></pre></td></tr></table></figure>

<p>我们简单的在web.xml 中的 <code>&lt;servlet&gt;&lt;/servlet&gt;</code> 标签中添加如下内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 是否有边框--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.border<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>no<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>    </div><div class="line">  <span class="comment">&lt;!-- 字体颜色 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.font.color<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>red<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 图片宽度 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.image.width<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>100<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 使用哪些字符生成验证码 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.char.string<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>ACDEFHKPRSTWX345679<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 图片高度 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.image.height<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>30<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 字体大小 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.font.size<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>28<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 干扰线的颜色 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.noise.color<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>red<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 字符个数 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.char.length<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>4<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 使用哪些字体 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.font.names<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>Arial<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div></pre></td></tr></table></figure>

<p>之后无需重启Tomcat，直接刷新浏览器就可以看到最新的显示效果，现在我们就会发现生成的验证码很难被计算机所识别了。</p>
<p><img src="http://zhang1g.qiniudn.com/kaptcha-verify-code3.PNG" alt="经过配置的Kaptcha 验证码"></p>
<p><strong>汉字验证码的生成</strong></p>
<p>Kaptcha 组件中的文本实现类由 <code>com.google.code.kaptcha.text.impl.DefaultTextCreator</code> 默认实现，相应的配置如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--文本实现类--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.impl<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">param-value</span>&gt;</span></div><div class="line">    com.google.code.kaptcha.text.impl.DefaultTextCreator</div><div class="line">  <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div></pre></td></tr></table></figure>

<p>现在我们需要仿照DefaultTextCreator 自定义文本实现类，并将配置文件中的 <code>&lt;param-value&gt;&lt;/param-vaue&gt;</code> 改为我们的自定义实现类即可。</p>
<p>在Github 下载<a href="https://github.com/axet/kaptcha" target="_blank" rel="external">Kaptcha的源码</a>，这是一个使用maven 构建的项目，项目的结构如下所示</p>
<p><img src="http://zhang1g.qiniudn.com/kaptcha-source-structure.PNG" alt="Kaptcha的源码的目录结构"></p>
<p>在Kaptcha 的源码中有生成中文文本的实现类，但是实现过于简单，只能生成一些特定的汉字。因此我们仿照类 <code>DefaultTextCreator</code> 自己实现接口 <code>TextProducer</code> 并继承抽象类 <code>Configurable</code>。</p>
<p>在src 文件夹下新建package，并命名为com.zhang1g.test.kaptchaextend，在包下新建类ChinesetTextCreator，需要我们自己实现getText 方法。</p>
<p><code>ChinesetTextCreator.java</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinesetTextCreator</span> <span class="keyword">extends</span> <span class="title">Configurable</span> <span class="keyword">implements</span> <span class="title">TextProducer</span> </span>{</div><div class="line"></div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> String <span class="title">getText</span>() {</div><div class="line">    <span class="keyword">int</span> length = getConfig().getTextProducerCharLength();</div><div class="line">    String result = createRandomChinese(length);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> String <span class="title">createRandomChinese</span>(<span class="keyword">int</span> len) {</div><div class="line">    String ret = <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</div><div class="line">      String str = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">int</span> hightPos, lowPos; <span class="comment">// 定义高低位</span></div><div class="line">      Random random = <span class="keyword">new</span> Random();</div><div class="line">      hightPos = (<span class="number">176</span> + Math.abs(random.nextInt(<span class="number">39</span>))); <span class="comment">// 获取高位值</span></div><div class="line">      lowPos = (<span class="number">161</span> + Math.abs(random.nextInt(<span class="number">93</span>))); <span class="comment">// 获取低位值</span></div><div class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</div><div class="line">      b[<span class="number">0</span>] = (<span class="keyword">new</span> Integer(hightPos).byteValue());</div><div class="line">      b[<span class="number">1</span>] = (<span class="keyword">new</span> Integer(lowPos).byteValue());</div><div class="line">      <span class="keyword">try</span> {</div><div class="line">        str = <span class="keyword">new</span> String(b, <span class="string">"GBK"</span>); <span class="comment">// 转成中文</span></div><div class="line">      } <span class="keyword">catch</span> (UnsupportedEncodingException ex) {</div><div class="line">        ex.printStackTrace();</div><div class="line">      }</div><div class="line">      ret += str;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>其中方法createRandomChinese 可以随机生成不同的汉字，其原理可以参考文章<a href="http://blog.csdn.net/hanzengyi/article/details/4796905" target="_blank" rel="external">如何用java随机生成一个汉字?</a>，注意此处汉字的编码格式为GBK。</p>
<p>ChinesetTextCreator 和DefaultTextCreator 一样继承了Configurable抽象类，用来从配置文件中获取验证码的长度。</p>
<p>在实现了汉字生成类之后，需要对web.xml 中的配置参数进行修改，不要忘记要将默认的字体修改为<strong>宋体</strong>，否则验证码图片上的汉字会显示不出来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">    <span class="comment">&lt;!--文本实现类--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.impl<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span></div><div class="line">        com.zhang1g.test.kaptchaextend.ChinesetTextCreator</div><div class="line">      <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line">...</div><div class="line">    <span class="comment">&lt;!-- 使用哪些字体 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.font.names<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>宋体<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div></pre></td></tr></table></figure>

<p>验证码校验的功能可以参考文章<a href="http://zhangyigong.github.io/2015/01/16/verification-code-generated-by-java-servlet/" target="_blank" rel="external">漫谈验证码（一） 使用Servlet 生成验证码</a>中的实现。需要注意的是，因为之前汉字的编码设置为GBK，所以在获取Post 表单参数时需要对编码格式进行转换。具体实现如下所示，其中的 <code>index_userinput_verifycode</code> 为表单text 域的name 属性值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">req.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"><span class="constant">String userInputVerifyCode</span> = req.getParameter(<span class="string">"index_userinput_verifycode"</span>);</div></pre></td></tr></table></figure>

<p>至此，中文验证码的生成和校验就完成了，重新启动Tomcat 服务器，在浏览器中输入 <code>http://localhost:8080/KaptchaVerifyCode/</code> 即可看到如下效果</p>
<p><img src="http://zhang1g.qiniudn.com/verification-code-chinese1.PNG" alt="使用Kaptcha 组件生成中文验证码"></p>
<p><img src="http://zhang1g.qiniudn.com/verification-code-chinese2.PNG" alt="中文验证码校验成功"></p>
<p><strong>混合验证码的生成</strong></p>
<p>在实际应用中，如果同时使用四个汉字作为验证码，用户体验会很不友好，因此我们可以将英文字母、数字和汉字结合起来生成混合验证码，而且其中只出现一个汉字。</p>
<p>现在我们对文本生成类ChinesetTextCreator 的getText 方法进行修改，使它满足上述要求。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@<span class="type">Override</span></div><div class="line">public <span class="type">String</span> getText() {</div><div class="line">  <span class="type">int</span> length = getConfig().getTextProducerCharLength();</div><div class="line">  <span class="type">String</span> chineseVerifyCode = createRandomChinese(<span class="number">1</span>);</div><div class="line">  </div><div class="line">  <span class="type">char</span>[] charVerifyCodeCollection = <span class="string">"ABFGHJKMPRSUVXYZ034689"</span>.toCharArray();</div><div class="line">  <span class="type">Random</span> random = new <span class="type">Random</span>();</div><div class="line">  <span class="type">int</span> chineseverifyCodePos = random.nextInt(length); </div><div class="line">  <span class="type">int</span> charLen = charVerifyCodeCollection.length;</div><div class="line">  <span class="type">StringBuffer</span> sb = new <span class="type">StringBuffer</span>();</div><div class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;length ; i++) {</div><div class="line">    <span class="keyword">if</span> (i == chineseverifyCodePos) {</div><div class="line">      sb.append(chineseVerifyCode);</div><div class="line">    }<span class="keyword">else</span> {</div><div class="line">      <span class="type">int</span> index = random.nextInt(charLen);</div><div class="line">      sb.append(charVerifyCodeCollection[index]);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="type">String</span> <span class="literal">result</span> = sb.toString();</div><div class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>修改后重新启动Tomcat 服务器，刷新后效果如下</p>
<p><img src="http://zhang1g.qiniudn.com/verification-code-complex1.PNG" alt="Kaptcha 组件生成混合验证码"></p>
<p><img src="http://zhang1g.qiniudn.com/verification-code-complex2.PNG" alt="混合验证码校验成功"></p>
<p><strong>算式验证码的生成</strong></p>
<p>Kaptcha 组件生成复杂的验证码到此就可以结束了，但是在这里我们可以多讲一点点。很多网站的验证码使用了很多新奇的玩意儿，算式验证码就是其中的一种，下面我们对Kaptcha 组件进行一下扩展，使之也可以生成算式验证码。</p>
<p>要实现算式验证码，需要做以下几件事情：</p>
<ol>
<li>获取随机数值，结果相加</li>
<li>将计算公式写到验证码图片中</li>
<li>将相加的结果放到session中</li>
</ol>
<p>这里我们需要重写KaptchaServlet 类。</p>
<p>首先将Kaptcha 源码中的KaptchaServlet 类拷贝到工程中的包com.zhang1g.test.kaptchaextend 内，KaptchaServlet 类继承了HttpServlet，我们只需要重写其中的doGet 方法即可。</p>
<p><code>KaptchaServlet.java</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void doGet(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">    throws ServletException, IOException {</div><div class="line">  <span class="keyword">...</span></div><div class="line"></div><div class="line">  // create the text <span class="keyword">for</span> the image</div><div class="line">  String capText = this.kaptchaProducer.createText();</div><div class="line">  String s1 = capText.substring(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  String s2 = capText.substring(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  int result = Integer.valueOf(s1).intValue() + Integer.valueOf(s2).intValue();</div><div class="line"></div><div class="line">  // create the image with the text</div><div class="line">  // BufferedImage bi = this.kaptchaProducer.createImage(capText);</div><div class="line">  BufferedImage bi = this.kaptchaProducer.createImage(s1 + <span class="string">"+"</span> + s2</div><div class="line">      + <span class="string">"= ?"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">...</span></div><div class="line"></div><div class="line">  // store the text <span class="keyword">in</span> the session</div><div class="line">  // req.getSession().setAttribute(this.sessionKeyValue, capText);</div><div class="line">  req.getSession().setAttribute(this.sessionKeyValue,</div><div class="line">      String.valueOf(result));</div><div class="line"></div><div class="line">  <span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>之后修改web.xml 文件中配置的Servlet 类，将其改为我们自己实现的KaptchaServlet，并将我们之前的包含汉字和英文字母的文本生成类相关的配置注释掉，使用的字符集也改为只包含数字，因为这里只涉及到了个位数的加法，所以使用的字符个数改为2 个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></div><div class="line">  com.zhang1g.test.kaptchaextend.KaptchaServlet</div><div class="line"><span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">&lt;!--文本实现类--&gt;</span></div><div class="line"><span class="comment">&lt;!-- </span></div><div class="line">&lt;init-param&gt;</div><div class="line">    &lt;param-name&gt;kaptcha.textproducer.impl&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;</div><div class="line">      com.zhang1g.test.kaptchaextend.ChinesetTextCreator</div><div class="line">  &lt;/param-value&gt;</div><div class="line">&lt;/init-param&gt;   </div><div class="line">--&gt;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用哪些字符生成验证码 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.char.string<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>0123456789<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 字符个数 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.char.length<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>2<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>

<p>修改完毕之后重新启动服务器，刷新浏览器即可看到算式验证码的最终效果。</p>
<p><img src="http://zhang1g.qiniudn.com/verification-code-number1.PNG" alt="Kaptcha 组件生成算式验证码"></p>
<p><img src="http://zhang1g.qiniudn.com/verification-code-number2.PNG" alt="算式验证码校验结果"></p>
<p>至此，使用kaptcha 组件生成各类复杂验证码的工作就全部完成了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="开源组件简介">开源组件简介</h2>
<p>在<a href="http://zhangyigong.github.io/2015/01/16/verification-code-generated-by-java-servlet/" target="_blank" rel="external">漫谈验证码（一） 使用Servlet 生成验证码</a>一文中，我们介绍了使用Servlet 生成验证码的方法。但是生成的验证码图片比较简单，使用图像识别的方法还是很容易破解，因此我们在实际应用中希望能够生成比较复杂的验证码图片，比如汉字、算式等，并且添加一些干扰。</p>
<p>使用一些相关的开源组件可以很容易的实现上述功能。常见的开源组件包括Kaptcha、jCaptcha 和Simplecaptcha。</p>
<p>SimpleCaptcha 是很棒的项目，但是，SimpleCaptcha 似乎没有被维护和更新，在JDK1.5 和Servlet 输出的HTTP 头部情况下还存在一些问题，有一堆的错误报告。 近几年，SimpleCaptcha 的论坛没有任何的消息，也没有新的版本或任何改变。 </p>
<p>jCaptcha 是很多Java 开发者使用的验证码组件，但是默认的配置相对有点恶心，它是一个很棒的项目，但绝对不是一个快速解决方案，更像是一个库。在网站上，它默认输出的样式不是太难分辨就是不够好，也相当的慢。</p>
<p>肯定的是，你需要花很多的时间来熟悉它的API。但事实是，我愿意是一个简单的jar 包文件，轻松地导入我的项目，然后在web.xml 添加几行代码即可。 </p>
<p>因此，这里推荐一个非常简单的验证码组件：<strong>Kaptcha</strong>。 </p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://zhangyigong.github.com/tags/java/"/>
    
      <category term="web" scheme="http://zhangyigong.github.com/tags/web/"/>
    
      <category term="opensource" scheme="http://zhangyigong.github.com/tags/opensource/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[漫谈验证码（一） 使用Servlet 生成验证码]]></title>
    <link href="http://zhangyigong.github.com/2015/01/16/verification-code-generated-by-java-servlet/"/>
    <id>http://zhangyigong.github.com/2015/01/16/verification-code-generated-by-java-servlet/</id>
    <published>2015-01-15T16:45:07.000Z</published>
    <updated>2015-03-09T02:21:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么要使用验证码">为什么要使用验证码</h2>
<p>输入验证码是一个很麻烦的一个过程，很多用户都不喜欢，但是验证码却总是存在于各类的网站和Web 应用中，比如</p>
<ul>
<li>回复帖子的时候</li>
<li>申请账号的时候</li>
<li>用户登录的时候<br>…</li>
</ul>
<p>为什么要使用验证码呢？</p>
<p>因为计算机可以模拟人的行为对网站进行一系列的操作，如果不使用验证码，将会导致一些可怕的事情发生</p>
<ul>
<li>对特定用户不断登录破解密码</li>
<li>对某个网站不断创建无效账户</li>
<li>对某个网站提交垃圾数据</li>
<li>对网站投票进行刷票<br>…</li>
</ul>
<a id="more"></a>

<h2 id="什么是验证码">什么是验证码</h2>
<p>有验证码的登录过程如下</p>
<p><img src="http://zhang1g.qiniudn.com/verification-code2.png" alt="有验证码的登录过程"></p>
<p>那么，我们使用验证码只有一个原因，就是通过验证码，由用户肉眼识别其中的验证信息，从而区分用户是人还是计算机。</p>
<p>验证码定义：</p>
<blockquote>
<p>一种区分用户是人还是计算机的公共全自动程序。</p>
</blockquote>
<h2 id="使用Servlet_生成验证码概述">使用Servlet 生成验证码概述</h2>
<p>我们知道，网页中的验证码包含两部分：</p>
<ol>
<li><p>输入框</p>
</li>
<li><p>显示验证码的图片</p>
</li>
</ol>
<p>那么验证码的图片是如何获取的？</p>
<p>我们没有必要事先准备大量的验证码图片，可以使用Servlet 在初次显示验证码或者刷新验证码时实时生成。下面是一个包含验证码的网页源码的一部分</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"verifyCode"</span> name=<span class="string">"verifyCode"</span> size=<span class="string">"6"</span>/&gt;</div><div class="line"><span class="keyword">...</span></div><div class="line">&lt;img alt=<span class="string">"验证码"</span> id=<span class="string">"safecode"</span> src=<span class="string">"&lt;%=request.getContextPath()%&gt;/</span></div><div class="line">		servlet/ImageServlet"/&gt;</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>整个过程中需要两个自定义类，其中<strong>ImageServlet</strong> 用来生成验证码，<strong>LogionServlet</strong> 用来校验验证码是否正确。</p>
<p><strong>ImageServlet 类</strong></p>
<p>使用ImageServlet 生成图片需要用到的类包括</p>
<ul>
<li>BufferedImage 图像数据缓冲区</li>
<li>Graphics 绘制图片</li>
<li>Color 获取颜色</li>
<li>Random 生成随机数</li>
<li>ImageIO 输出图片</li>
</ul>
<p>生成验证码的类ImageServlet 的具体实现流程如下</p>
<ol>
<li><p>定义BufferedImage 对象</p>
</li>
<li><p>获得Graphics 对象</p>
</li>
<li><p>通过Random 产生随机验证码信息</p>
</li>
<li><p>使用Graphics 类绘制图片</p>
</li>
<li><p>记录验证码信息到session 中</p>
</li>
<li><p>使用ImageIO 输出图片</p>
</li>
</ol>
<p><strong>LoginServlet 类</strong></p>
<p>使用LoginServlet 校验验证码是否正确需要以下几个步骤</p>
<ol>
<li><p>获取页面上用户输入的验证码</p>
</li>
<li><p>获取session 保存的验证码</p>
</li>
<li><p>比较验证码</p>
</li>
<li><p>返回校验结果</p>
</li>
</ol>
<p>使用ImageServlet 和LoginServlet 实现验证码生成和校验的流程如下</p>
<p><img src="http://zhang1g.qiniudn.com/verification-code3.png" alt="实现验证码生成和校验的流程"></p>
<h2 id="使用servlet_生成验证码代码实现">使用servlet 生成验证码代码实现</h2>
<p><strong>新建Java Web 工程</strong></p>
<p>将新建的工程命名为<code>ServletVerificationCode</code>，在项目名称上点击右键属性，将工程的编码格式改为UTF-8。</p>
<p>在src 目录下新建一个名为 <code>com.zhang1g.test</code> 的包，在包下新建类 <code>ImageServlet</code> 和 <code>LoginServlet</code>，这两个类都继承HttpServlet 抽象类。</p>
<p>编辑WEB-INF 目录下的index.jsp 文件，pageEncoding 改为UTF-8，在body 中增加一个form 表单，其中包含一个img 标签用来显示验证码，一个文本输入框用来输入验证码以及一个提交按钮。具体代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;form <span class="variable">action=</span><span class="string">"&lt;%=request.getContextPath()%&gt;/servlet/LoginServlet"</span> </div><div class="line">		<span class="variable">method=</span><span class="string">"post"</span>&gt;</div><div class="line">	&lt;br&gt; </div><div class="line">	&lt;img <span class="variable">alt=</span><span class="string">"验证码"</span> <span class="variable">id=</span><span class="string">"index_image_verify_code"</span></div><div class="line">		<span class="variable">src=</span><span class="string">"&lt;%=request.getContextPath()%&gt;/servlet/ImageServlet"</span>&gt; </div><div class="line">	&lt;br&gt;</div><div class="line">	&lt;input <span class="variable">type=</span><span class="string">"text"</span> <span class="variable">name=</span><span class="string">"index_userinput_verifycode"</span></div><div class="line">		<span class="variable">id=</span><span class="string">"index_userinput_verifycode"</span> <span class="variable">size=</span><span class="string">"6"</span> /&gt; </div><div class="line">	&lt;a <span class="variable">href=</span><span class="string">"#"</span>&gt;看不清楚&lt;/a&gt; </div><div class="line">	&lt;br&gt; &lt;br&gt; </div><div class="line">	&lt;input <span class="variable">type=</span><span class="string">"submit"</span> <span class="variable">value=</span><span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>

<p>其中 <code>&lt;%=request.getContextPath()%&gt;</code> 表示项目工程的路径，form 表单的action 和img 的src 属性向后台的Servlet 请求数据，一个是post 请求，一个是get 请求，分别对应两个Servlet实现类：LoginServlet 和ImageServlet。</p>
<p><strong>在web.xml 中配置Servlet</strong></p>
<p>web.xml 在WEB-INF 的lib 目录下，针对上述两个Servlet进行配置，分别添加 <code>&lt;servlet&gt;&lt;/servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;&lt;/servlet-mapping&gt;</code> 项。具体配置如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.zhang1g.test.ImageServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.zhang1g.test.LoginServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ImageServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/servlet/ImageServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/servlet/LoginServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>

<p><strong>ImageServlet 具体实现</strong></p>
<p>在类中自定义实现父类的doGet 方法，将生成的验证码放入session 中，并绘制验证码图片添加到response 输出流中。具体代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class ImageServlet extends HttpServlet {</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void doGet(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">			throws ServletException, IOException {</div><div class="line">		BufferedImage bufferedVerifyCodeImage = new BufferedImage(</div><div class="line">			75, 22, BufferedImage.TYPE_INT_RGB);</div><div class="line">		Graphics graphics = bufferedVerifyCodeImage.getGraphics();</div><div class="line">		</div><div class="line">		Color backgroundColor = new Color(200,150,255);</div><div class="line">		graphics.setColor(backgroundColor);</div><div class="line">		graphics.fillRect(0, 0, 75, 22);</div><div class="line">		</div><div class="line">		char[] verifyCodeCollection = </div><div class="line">			<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>.toCharArray();</div><div class="line">		Random random = new Random();</div><div class="line">		int len = verifyCodeCollection.length;</div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		for (int i = 0; i &lt;4 ; i++) {</div><div class="line">			int index = random.nextInt(len);</div><div class="line">			graphics.setColor(new Color(random.nextInt(88),</div><div class="line">				random.nextInt(188),random.nextInt(255)));</div><div class="line">			graphics.drawString(verifyCodeCollection[index]+<span class="string">""</span>, </div><div class="line">				(i*15)+3, 18);</div><div class="line">			</div><div class="line">			sb.append(verifyCodeCollection[index]);</div><div class="line">		}</div><div class="line">		</div><div class="line">		req.getSession().setAttribute(<span class="string">"picVerifyCode"</span>, </div><div class="line">			sb.toString());</div><div class="line">		ImageIO.write(bufferedVerifyCodeImage, <span class="string">"JPG"</span>, </div><div class="line">			resp.getOutputStream());</div><div class="line">	}</div><div class="line">	</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>LoginServlet 具体实现</strong></p>
<p>在类中通过request 获取用户输入的验证码信息，并与session 中的验证码进行比较，如果一致则跳转到success 页面，如果不一致则跳转到fail 页面。具体实现如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span>(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">			<span class="keyword">throws</span> ServletException, IOException {		</div><div class="line">		String picVerifyCode = </div><div class="line">			(String)req.getSession().getAttribute(<span class="string">"picVerifyCode"</span>);</div><div class="line">		String userInputVerifyCode = </div><div class="line">			req.getParameter(<span class="string">"index_userinput_verifycode"</span>);</div><div class="line">			</div><div class="line">		<span class="keyword">if</span> (userInputVerifyCode.toUpperCase().equals(picVerifyCode)) {</div><div class="line">			RequestDispatcher view = </div><div class="line">				req.getRequestDispatcher(<span class="string">"/success.jsp"</span>);</div><div class="line">			view.forward(req, resp);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			RequestDispatcher view = </div><div class="line">				req.getRequestDispatcher(<span class="string">"/fail.jsp"</span>);</div><div class="line">			view.forward(req, resp);</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>编辑验证成功和失败页面</strong></p>
<p>在WEB-INFO 下新建success.jsp 和fail.jsp 两个页面，pageEncoding 改为UTF-8，这两个页面的内容基本一致。</p>
<p>由于页面中用到了JSTL 表达式和EL 表达式，因此需要在项目中添加JSTL 支持，即在项目的WEB-INFO/lib 目录下添加jstl.jar 和standard.jar（可以从tomcat 的示例代码中copy），并在JSP 页面中包含语句 <code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;</code> 。</p>
<p><code>success.jsp</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt; </div><div class="line">...</div><div class="line"></div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;check <span class="literal">result</span>&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  </div><div class="line">  &lt;body&gt;</div><div class="line">  	&lt;c:<span class="keyword">out</span> value=<span class="string">"图片上的验证码信息为：${sessionScope.picVerifyCode}"</span> </div><div class="line">  		default=<span class="string">""</span> /&gt;</div><div class="line">  	&lt;br&gt;</div><div class="line">  	&lt;c:<span class="keyword">out</span> value=<span class="string">"输入的验证码信息为：${param.index_userinput_verifycode}"</span> </div><div class="line">  		default=<span class="string">""</span> /&gt;</div><div class="line">  	&lt;br&gt;&lt;br&gt;</div><div class="line">  	验证码输入正确！</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure>

<p><code>fail.jsp</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="vbscript">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt;</span> </div><div class="line">...</div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>验证码校验结果<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="title">c:out</span> <span class="attribute">value</span>=<span class="value">"图片上的验证码信息为：${sessionScope.picVerifyCode}"</span> </span></div><div class="line">  		<span class="attribute">default</span>=<span class="value">""</span> /&gt;</div><div class="line">  	<span class="tag">&lt;<span class="title">br</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="title">c:out</span> <span class="attribute">value</span>=<span class="value">"输入的验证码信息为：${param.index_userinput_verifycode}"</span> </span></div><div class="line">  		<span class="attribute">default</span>=<span class="value">""</span> /&gt;</div><div class="line">  	<span class="tag">&lt;<span class="title">br</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span></div><div class="line">  	验证码输入错误！</div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div></pre></td></tr></table></figure>

<p><strong>添加刷新验证码功能</strong></p>
<p>在首页index.jsp 中，为了防止显示的验证码不是很清楚，添加了 <code>看不清楚</code> 超链接，重新向后台的ImageServlet 发出请求，显示新的验证码图片。</p>
<p>更改 <code>&lt;a href=&quot;#&quot;&gt;看不清楚&lt;/a&gt;</code> 为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:reloadVerifyCode()"</span>&gt;</span>看不清楚<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>在<head></head> 中添加重新加载验证码图片的js 代码，并实现reloadVerifyCode 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">reloadVerifyCode</span><span class="params">()</span> </span>{</div><div class="line">		<span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</div><div class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"index_image_verify_code"</span>).src = </div><div class="line">			<span class="string">"&lt;%=request.getContextPath()%&gt;/servlet/ImageServlet?d="</span></div><div class="line">			 + time;</div><div class="line">	}</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>其中的src 除了ImageServlet 对应的URL 链接外，另外添加了time 变量，用来解决由于浏览器缓存导致的验证码图片无法刷新的问题。</p>
<p><strong>在Tomcat 中运行项目工程</strong></p>
<p>在eclipse 中配置好Tomcat 服务器，并将项目运行在配置好的Tomcat 中，打开浏览器，输入 <code>http://localhost:8080/ServletVerificationCode/</code> 即可在浏览其中看到如下效果</p>
<p><img src="http://zhang1g.qiniudn.com/servlet-verifycode1.PNG" alt="Servlet 生成验证码效果"></p>
<p>输入正确的验证码后，点击提交按钮，可以看到</p>
<p><img src="http://zhang1g.qiniudn.com/servlet-verifycode-success.PNG" alt="Servlet 生成验证码效果"></p>
<p>至此使用Servlet 生成验证码的工作就全部完成了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么要使用验证码">为什么要使用验证码</h2>
<p>输入验证码是一个很麻烦的一个过程，很多用户都不喜欢，但是验证码却总是存在于各类的网站和Web 应用中，比如</p>
<ul>
<li>回复帖子的时候</li>
<li>申请账号的时候</li>
<li>用户登录的时候<br>…</li>
</ul>
<p>为什么要使用验证码呢？</p>
<p>因为计算机可以模拟人的行为对网站进行一系列的操作，如果不使用验证码，将会导致一些可怕的事情发生</p>
<ul>
<li>对特定用户不断登录破解密码</li>
<li>对某个网站不断创建无效账户</li>
<li>对某个网站提交垃圾数据</li>
<li>对网站投票进行刷票<br>…</li>
</ul>
]]>
    
    </summary>
    
      <category term="java" scheme="http://zhangyigong.github.com/tags/java/"/>
    
      <category term="web" scheme="http://zhangyigong.github.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Github Pages 和Hexo 搭建独立博客]]></title>
    <link href="http://zhangyigong.github.com/2015/01/13/bulid-blog-with-githubpages-and-hexo/"/>
    <id>http://zhangyigong.github.com/2015/01/13/bulid-blog-with-githubpages-and-hexo/</id>
    <published>2015-01-13T14:27:57.000Z</published>
    <updated>2015-03-09T02:15:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么选择GitHub_Pages？">为什么选择GitHub Pages？</h2>
<p>一直想搭建一个自己的独立博客，后来发现了Hexo 这个逼格极高的方式，而且比起Github Pages 官方推荐的Jekyll 操作要简便的多，因此就使用Github Pages 服务和Hexo 搭建了现在这个博客。</p>
<p>这是一个在Win7 搭建独立博客的教程，我希望尽可能写的详细，给后来者一个指引。在搭建博客的过程中我摘录了其他人的一些教程，感谢这些作者们，在教程的最后我也会列出相关的链接。</p>
<p>下面开始我们的博客搭建之旅。</p>
<p>很多人选择Wordpress 来搭建博客，但是相对会麻烦一点，<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a> 可以被认为是用户编写的、托管在github上的静态网页，它是Github 推出的一项服务，本来是用于介绍托管在GitHub 的项目，不过，由于它的空间免费稳定，用来做搭建一个博客再好不过了。</p>
<p>GitHub Pages 拥有两种Pages 模式</p>
<ul>
<li>User/Organization Pages 个人或公司站点</li>
<li>Project Pages 项目站点</li>
</ul>
<a id="more"></a>

<p>我们使用第一种模式，但是需要注意以下几点</p>
<ol>
<li><p>使用自己的Github 用户名，每个用户名下面只能建立一个</p>
</li>
<li><p>资源命名必须符合这样的规则 <code>username/username.github.com</code></p>
</li>
<li><p>主干上内容被用来构建和发布页面</p>
</li>
</ol>
<p>使用Github Pages 可以</p>
<ol>
<li><p>享有300M 免费空间，资料自己管理，保存可靠</p>
</li>
<li><p>支持静态脚本</p>
</li>
<li><p>本身提供有Github 的二级域名，也可以绑定自己申请的域名</p>
</li>
<li><p>可以使用Jekyll、Octopress、Hexo 等工具对博客进行DIY</p>
</li>
</ol>
<h2 id="什么是Hexo?">什么是Hexo?</h2>
<p>hexo出自台湾大学生<a href="http://zespia.tw/" target="_blank" rel="external">tommy351</a> 之手，是一个基于Node.js 的静态博客程序，其编译上百篇文字只需要几秒。Hexo 生成的静态网页可以直接放到GitHub Pages，BAE，SAE 等平台上。</p>
<p>作者在<a href="http://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="external">Hexo 颯爽登場！</a>一文中吐槽了一下Octopress，并简单介绍了Hexo 的使用。相比Octopress 或者Jekyll 等静态网页生成器，Hexo 不仅生成网页的速度更快，而且操作命令也极其简单。</p>
<p>虽然在搭建过程或许会觉得有点小繁琐，但一旦博客搭建完成，写文章是极简单，极舒服的。只需要几个简单命令，就可以完成一切。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo n title <span class="comment">#写文章</span></div><div class="line"><span class="variable">$ </span>hexo g 	<span class="comment">#生成</span></div><div class="line"><span class="variable">$ </span>hexo d 	<span class="comment">#部署 # 可与hexo g合并为 hexo d -g</span></div></pre></td></tr></table></figure>

<h2 id="Node-js_安装">Node.js 安装</h2>
<p><strong>安装包下载</strong> </p>
<p>到<a href="http://nodejs.org/" target="_blank" rel="external">Node.js 官网</a>下载最新版本的安装包，一路安装即可。</p>
<p><img src="http://zhang1g.qiniudn.com/nodejs-install.PNG" alt="Node.js 官网安装包下载"></p>
<p><strong>设置环境变量</strong></p>
<p><code>我的电脑</code> 右键 <code>属性</code> 找到 <code>高级系统设置</code> <code>高级</code> <code>环境变量</code>，在系统变量Path 后添加对应的安装目录，比如 <code>C:\Program Files\nodejs\;</code>。</p>
<p>配置成功后在cmd 中通过 <code>node --version</code> 来查看Node.js 对应的版本号。</p>
<p><strong>安装模块管理工具npm</strong></p>
<p>下载<a href="https://github.com/npm/npm/tags" target="_blank" rel="external">nmp 源码</a>，将npm 源代码解压到D:\npmjs 目录中。</p>
<p>在命令提示符窗口中执行下面的操作，完成npm 的安装：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span><span class="constant">D</span><span class="symbol">:</span>\&gt;cd npmjs</div><div class="line"><span class="variable">$ </span><span class="constant">D</span><span class="symbol">:</span>\npmjs&gt;node cli.js install -gf</div></pre></td></tr></table></figure>

<p>npm 安装完成后，将 <code>D:\nodejs\node_modules</code> 加入系统环境变量Path 中。</p>
<h2 id="Git_安装和Github_设置">Git 安装和Github 设置</h2>
<p><strong>安装Git 客户端</strong></p>
<p>Git的客户端很多，我用的是<a href="http://code.google.com/p/msysgit" target="_blank" rel="external">msysgit</a>，可以在百度云中搜索并下载绿色版，安装后设置环境变量。</p>
<p>我们会用到msysgit 的Git Bash 工具。</p>
<p><strong>Github 设置</strong></p>
<ol>
<li><p>注册一个GitHub 帐号，已有的请忽略。</p>
</li>
<li><p>建立与用户名对应的仓库，仓库名必须为 <code>your_user_name.github.com</code>。</p>
</li>
<li><p>添加SSH Key到Github。 </p>
</li>
</ol>
<p>下面具体说一下如何添加SSH Key。</p>
<ul>
<li>打开Git Bash，检查电脑上现有的ssh key</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh</div></pre></td></tr></table></figure>

<p>如果提示：<code>No such file or directory</code> 说明是第一次使用Git。</p>
<ul>
<li>生成密钥</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"name@163.com"</span></div><div class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</div><div class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</div></pre></td></tr></table></figure>

<p>然后系统会要你输入密码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">Enter</span> passphrase (empty <span class="keyword">for</span> no passphrase)<span class="symbol">:&lt;</span>输入加密串&gt;</div><div class="line"><span class="constant">Enter</span> same passphrase <span class="symbol">again:</span>&lt;再次输入加密串&gt;</div></pre></td></tr></table></figure>

<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>
<p>设置成功后会出现如下所示的界面。</p>
<p><img src="http://zhang1g.qiniudn.com/SSH-set-success.png" alt="SSH Key 设置成功"></p>
<ul>
<li>添加SSH Key 到Github</li>
</ul>
<p>打开本地 <code>C:\Documents and Settings\Administrator.ssh\id_rsa.pub</code> 文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</p>
<p>登陆Github，点击右上角的 <code>Account settings</code> -&gt; <code>SSH Keys</code> -&gt; <code>Add SSH Key</code>。</p>
<p>把本地生成的密钥复制到里面（key文本框中）， 点击add key 就可以了。</p>
<p><img src="http://zhang1g.qiniudn.com/github-SSH.PNG" alt="Github 添加SSH Key"></p>
<ul>
<li>测试SSH Key 是否设置成功</li>
</ul>
<p>输入下面的命令，可以测试设置是否成功，<code>git@github.com</code> 的部分不要修改</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>ssh -<span class="constant">T</span> git<span class="variable">@github</span>.com</div></pre></td></tr></table></figure>

<p>如果是下面的反馈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (207.97.227.239)' can't be established.</span></div><div class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></div><div class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</div></pre></td></tr></table></figure>

<p>不要紧张，输入yes 后会看到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi xxx! You<span class="attribute">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</div></pre></td></tr></table></figure>

<ul>
<li>设置用户名和密码</li>
</ul>
<p>现在已经可以通过SSH 连接到GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global <span class="literal">user</span>.email <span class="string">"name@163.com"</span></div><div class="line">$ git config --global <span class="literal">user</span>.name <span class="string">"name"</span></div></pre></td></tr></table></figure>

<h2 id="Hexo_安装">Hexo 安装</h2>
<p>Node.js 和Git 都安装好后，可执行如下命令安装Hexo</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>npm install -g hexo</div></pre></td></tr></table></figure>

<p>安装完成后可以参考<a href="http://hexo.io/docs/index.html" target="_blank" rel="external">Hexo 的官方文档</a>获取详细的使用说明。这里只是简单介绍一下Hexo 的使用。</p>
<p>在我的电脑中建立一个名字叫HexoBlog 的文件夹，然后在此文件夹中右键打开Git Bash。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo init</div></pre></td></tr></table></figure>

<p>Hexo 随后会自动在目标文件夹建立网站所需要的所有文件。</p>
<p>现在我们已经搭建起本地的Hexo 博客了，在HexoBlog 文件夹下执行以下命令，然后到浏览器输入 <code>localhost:4000</code> 即可看到搭建的博客。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo g</div><div class="line"><span class="variable">$ </span>hexo s <span class="comment">#本地启动</span></div></pre></td></tr></table></figure>

<p>命令必须在init目录（HexoBlog 文件夹）下执行，否则不成功，但是也不报错。<br>当你修改文章Tag 或内容，不能正确重新生成内容，可以删除 <code>HexoBlog\db.json</code> 后重试，还不行就到 <code>public</code> 目录删除对应的文件，重新生成。</p>
<h2 id="修改博客的主题">修改博客的主题</h2>
<p>Hexo 提供了很多主题，可以参考<a href="http://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">Hexo 的主题列表</a>选择自己喜欢的主题。</p>
<p>我比较喜欢的有Jacman 和 Yilia，Jacman提供的功能比较齐全，而Yilia 看起来则很优雅大方。</p>
<p>我的博客选取的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia 主题</a>。</p>
<p><strong>安装主题</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/litten</span><span class="regexp">/hexo-theme-yilia.git themes/yilia</span></div></pre></td></tr></table></figure>

<p>安装完成后，打开 <code>HexoBlog\_config.yml</code> ，修改主题为 <code>yilia</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">theme</span>: <span class="string">yilia</span></div></pre></td></tr></table></figure>

<p><strong>更新主题</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd themes/yilia</div><div class="line"><span class="variable">$ </span>git pull</div></pre></td></tr></table></figure>

<p>yilia 主题下 <code>_congif.yml</code> 文件的配置可以参考文章<a href="http://litten.github.io/2014/08/31/hexo-theme-yilia/" target="_blank" rel="external">Hexo主题Yilia</a>。</p>
<p>修改主文件下的 <code>_congif.yml</code>，修改的内容包括</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site</span></div><div class="line">title: xxx的Blog</div><div class="line">subtitle: xxx xxx</div><div class="line"></div><div class="line">description: xxx xxx</div><div class="line">author: xxx</div><div class="line">email: name@<span class="number">163.</span>com</div><div class="line">language: </div><div class="line"></div><div class="line"><span class="keyword">...</span></div><div class="line"></div><div class="line">url: http://username.github.com</div><div class="line"></div><div class="line"><span class="keyword">...</span></div><div class="line"></div><div class="line">archive: <span class="number">1</span></div><div class="line">category: <span class="number">1</span></div><div class="line">tag: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">...</span></div><div class="line"></div><div class="line">date_format: MMM DD </div><div class="line"></div><div class="line"><span class="keyword">...</span></div><div class="line"></div><div class="line">theme: yilia</div><div class="line">exclude_generator:</div><div class="line">plugins:</div><div class="line">- hexo-generator-feed</div><div class="line"></div><div class="line"><span class="comment"># Stylus</span></div><div class="line">stylus:</div><div class="line">  compress: true</div><div class="line"></div><div class="line"><span class="keyword">...</span></div><div class="line"></div><div class="line">deploy:</div><div class="line">  type: github</div><div class="line">  repository: https://github.com/username/username.github.com.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>

<p><strong>安装RSS 订阅插件</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>npm install hexo-generator-feed</div></pre></td></tr></table></figure>

<p><strong>添加多说评论</strong></p>
<p>静态博客要使用第三方评论系统，Hexo 默认集成的是Disqus ，在国内的话还是建议用<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a> 。 </p>
<p>登陆之后进入后台管理并添加站点，进行基本设置并保存。</p>
<p><img src="http://zhang1g.qiniudn.com/duoshuo-set.PNG" alt="多说后台管理设置"></p>
<p>之后获取通用代码</p>
<p><img src="http://zhang1g.qiniudn.com/duoshuo-tongyongcode.PNG" alt="获取多说的通用代码"></p>
<p>在 <code>HexoBlog/themes/yilia/layout/_partial</code> 文件夹下找到 <code>duoshuo.ejs</code> 文件,该文件已经添加了相关的通用代码，我们只需要查看通用代码中的shortname，并将其添加到主题yilia 下的 <code>_config.yml</code> 文件中的相应位置即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">duoshuo</span>: <span class="string">shortname</span></div></pre></td></tr></table></figure>

<h2 id="发表文章">发表文章</h2>
<p><strong>Hexo 命令</strong></p>
<p>用hexo发表新文章，使用如下命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo n title <span class="comment">#写文章</span></div></pre></td></tr></table></figure>

<p>其中title 为文章标题，执行命令后，会在项目\source_posts中生成title.md文件，用编辑器打开编写即可。<br>当然，也可以直接在\source_posts中新建一个md文件。</p>
<p>写完后，推送到服务器上，执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>hexo g <span class="comment">#生成</span></div><div class="line"><span class="variable">$ </span>hexo d <span class="comment">#部署 # 可与hexo g合并为 hexo d -g</span></div></pre></td></tr></table></figure>

<p><strong>用Hexo 发表文章的Markdown 语法</strong></p>
<p>使用主题yilia，建议按照下面的标准语法写</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">title: postName #文章页面上的显示名称，可以任意修改</div><div class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</div><div class="line">tags: #文章标签，可空，多标签请用格式，注意:后面有个空格</div><div class="line"><span class="bullet">- </span>tag1</div><div class="line"><span class="header">- tag2 </span></div><div class="line">---</div><div class="line"></div><div class="line">摘要</div><div class="line">&lt;!--more--&gt;</div><div class="line">以下正文</div></pre></td></tr></table></figure>

<p>关于正文撰写的相关Markdown 语法可以参考文章<a href="http://zhangyigong.github.io/2015/01/13/markdown-grammar/" target="_blank" rel="external">使用Markdown 语法编辑博客内容</a>。</p>
<p><strong>支持Markdown 语法的编辑器</strong></p>
<p>这里我推荐Sublime，<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 2</a>在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，也支持Markdown语法，是个不可多得的练码奇才。</p>
<p>下载好Sublime Text 2后无需安装即可直接使用，使用教程可以参考</p>
<ul>
<li><a href="http://www.jianshu.com/p/378338f10263" target="_blank" rel="external">sublime text 2 下的Markdown写作</a></li>
<li><a href="http://lucifr.com/2011/08/31/sublime-text-2-tricks-and-tips/" target="_blank" rel="external">Sublime Text 2 入门及技巧</a></li>
</ul>
<p>在发布文章时如果出现乱码，需要用Sublime Text 将md 文件的编码格式改为UTF-8。</p>
<p><strong>支持编辑数学公式</strong></p>
<p>虽不是经常跟数学公式打交道，但一旦需要让网页上出现数学公式只能截图，再插入到文章中，想想都觉得麻烦，在网上搜到一种很好的方法来解决这个问题。</p>
<p>这种工具就是mathjax，它能很好的在所有的浏览器中很好的显示数学公式，而且用起来很方便．只需要在页面中加入一段javascript 的引用代码即可。</p>
<ul>
<li>新建ejs</li>
</ul>
<p>在 <code>yilia\layout\_partial\</code> 下面新建 <code>mathjax.ejs</code> 文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript"></span></div><div class="line">  MathJax.Hub.Config({</div><div class="line">    tex2jax: {</div><div class="line">      inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</div><div class="line">      processEscapes: <span class="literal">true</span></div><div class="line">    }</div><div class="line">  });</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript"></span></div><div class="line">    MathJax.Hub.Config({</div><div class="line">      tex2jax: {</div><div class="line">        skipTags: [<span class="string">'script'</span>, <span class="string">'noscript'</span>, <span class="string">'style'</span>, <span class="string">'textarea'</span>, <span class="string">'pre'</span>, <span class="string">'code'</span>]</div><div class="line">      }</div><div class="line">    });</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript"></span></div><div class="line">    MathJax.Hub.Queue(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">var</span> all = MathJax.Hub.getAllJax(), i;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) {</div><div class="line">            all[i].SourceElement().parentNode.className += <span class="string">' has-jax'</span>;</div><div class="line">        }</div><div class="line">    });</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>页面引入</li>
</ul>
<p>同样也在 <code>yilia\layout\_partial\</code> 这个目录下面的 <code>after_foot.ejs</code> 中引入新建的文件 <code>mathjax.ejs</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="variable">%-</span> partial(<span class="string">'mathjax'</span>) <span class="variable">%&gt;</span></div></pre></td></tr></table></figure>

<hr>
<p>至此，博客搭建的过程就全部完成了。</p>
<p>如果不喜欢Github 提供的二级域名，也可以在Godaddy 上申请适合自己的域名，之后用DNSpod 进行域名绑定即可，关于这部分内容在之后的博客中会和大家一起分享。</p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><p><a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></p>
</li>
<li><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a></p>
</li>
<li><p><a href="http://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">使用GitHub和Hexo搭建免费静态Blog</a></p>
</li>
<li><p><a href="http://blog.yidongzhifu.net/2014/06/04/hexo%E4%B8%BB%E9%A2%98%E6%94%AF%E6%8C%81%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="external">hexo博客支持编辑数学公式</a></p>
</li>
<li><p><a href="http://jianyan.me/2014/06/21/how-to-build-a-free-static-blog-hexo-and-github-notes/" target="_blank" rel="external">如何搭建免费静态博客——Hexo 与 GitHub 使用小记</a></p>
</li>
<li><p><a href="http://www.leejianyang.com/2014/05/25/duoshuo_tutorial/" target="_blank" rel="external">Hexo添加多说评论框指南</a></p>
</li>
<li><p><a href="http://jingyan.baidu.com/article/6c67b1d68ed4bc2787bb1e83.html" target="_blank" rel="external">hexo github pages 首页不展示，出现代码怎么办</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">搭建一个免费的，无限流量的Blog——github Pages和Jekyll入门</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么选择GitHub_Pages？">为什么选择GitHub Pages？</h2>
<p>一直想搭建一个自己的独立博客，后来发现了Hexo 这个逼格极高的方式，而且比起Github Pages 官方推荐的Jekyll 操作要简便的多，因此就使用Github Pages 服务和Hexo 搭建了现在这个博客。</p>
<p>这是一个在Win7 搭建独立博客的教程，我希望尽可能写的详细，给后来者一个指引。在搭建博客的过程中我摘录了其他人的一些教程，感谢这些作者们，在教程的最后我也会列出相关的链接。</p>
<p>下面开始我们的博客搭建之旅。</p>
<p>很多人选择Wordpress 来搭建博客，但是相对会麻烦一点，<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a> 可以被认为是用户编写的、托管在github上的静态网页，它是Github 推出的一项服务，本来是用于介绍托管在GitHub 的项目，不过，由于它的空间免费稳定，用来做搭建一个博客再好不过了。</p>
<p>GitHub Pages 拥有两种Pages 模式</p>
<ul>
<li>User/Organization Pages 个人或公司站点</li>
<li>Project Pages 项目站点</li>
</ul>
]]>
    
    </summary>
    
      <category term="blog" scheme="http://zhangyigong.github.com/tags/blog/"/>
    
      <category term="hexo" scheme="http://zhangyigong.github.com/tags/hexo/"/>
    
      <category term="github" scheme="http://zhangyigong.github.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Markdown 语法编辑博客内容]]></title>
    <link href="http://zhangyigong.github.com/2015/01/13/markdown-grammar/"/>
    <id>http://zhangyigong.github.com/2015/01/13/markdown-grammar/</id>
    <published>2015-01-13T11:26:16.000Z</published>
    <updated>2015-03-09T02:19:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是_Markdown">什么是 Markdown</h2>
<p>Markdown 是一种方便记忆、书写的纯文本标记语言，我们可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这篇博客。</p>
<p>不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。</p>
<p><strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<p>可以使用Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p>它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<a id="more"></a>

<h3 id="书写一个复杂的公式">书写一个复杂的公式</h3>
<p>$$e^{\pi i}+1=?$$</p>
<h3 id="高亮一段代码">高亮一段代码</h3>
<p>比如下面是一段python 代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="decorator">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>

<h3 id="绘制表格">绘制表格</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h2 id="Markdown_的语法规则">Markdown 的语法规则</h2>
<p>Markdown 语法简洁明了，易于掌握，所以用它来写作是件既效率又舒服的事情。我们所熟知的和一些大型CMS，如Joomla!、Drupal 等都能很好的支持Markdown。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应HTML  标记的一小部分。Markdown 的构想不是要使得HTML 文档更容易书写。在我看来， HTML 已经很容易写了。</p>
<p>Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。下面列出了一些简单语法，详细的语法可以参考<a href="http://www.ituring.com.cn/article/775" target="_blank" rel="external">图灵社区</a>或者<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown 语法说明 (简体中文版)</a></p>
<h3 id="1-_斜体和粗体">1. 斜体和粗体</h3>
<p>使用 <em> 和 *</em> 表示斜体和粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>
<h3 id="2-_分级标题">2. 分级标题</h3>
<p>使用 === 表示一级标题，使用 —- 表示二级标题。</p>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="header">这是一个一级标题</span></div><div class="line">============================</div><div class="line"></div><div class="line"><span class="header">这是一个二级标题</span></div><div class="line">--------------------------------------------------</div><div class="line"></div><div class="line">### 这是一个三级标题</div></pre></td></tr></table></figure>

<p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>
<h3 id="3-_外链接">3. 外链接</h3>
<p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>示例：</p>
<p>这是去往 <a href="http://www.baidu.com" target="_blank" rel="external">百度</a> 的链接。</p>
<h3 id="4-_无序列表">4. 无序列表</h3>
<p>使用 *，+，- 表示无序列表。</p>
<p>示例：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h3 id="5-_有序列表">5. 有序列表</h3>
<p>使用数字和点表示有序列表。</p>
<p>示例：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h3 id="6-_文字引用">6. 文字引用</h3>
<p>使用 &gt; 表示文字引用。</p>
<p>示例：</p>
<blockquote>
<p>野火烧不尽，春风吹又生。</p>
</blockquote>
<h3 id="7-_行内代码块">7. 行内代码块</h3>
<p>使用 `代码` 表示行内代码块。</p>
<p>示例：</p>
<p>让我们聊聊 <code>html</code>。</p>
<h3 id="8-_代码块">8.  代码块</h3>
<p>使用 四个缩进空格 表示代码块。</p>
<p>示例：</p>
<pre><code>这是一个代码块，此行左侧有四个不可见的空格。
</code></pre><h3 id="9-_插入图像">9.  插入图像</h3>
<p>使用 ![描述](图片链接地址) 插入图像。图片的存储可以使用<a href="https://portal.qiniu.com" target="_blank" rel="external">七牛云存储</a>。</p>
<p>示例：</p>
<p><img src="http://zhang1g.qiniudn.com/shizi.jpg" alt="我的头像"></p>
<h3 id="10-_删除线">10. 删除线</h3>
<p>使用 ~~ 表示删除线。</p>
<p><del>这是一段错误的文本。</del></p>
<h3 id="11-_LaTeX_公式">11. LaTeX 公式</h3>
<p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<p>$$ 表示整行公式：</p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 可以参考更多使用方法。</p>
<h3 id="13-_表格支持">13. 表格支持</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| 项目        | 价格   |  数量  |</div><div class="line">| --------   | -----<span class="symbol">:</span>  | <span class="symbol">:----</span><span class="symbol">:</span>  |</div><div class="line">| 计算机     | <span class="variable">$1600</span> |   <span class="number">5</span>     |</div><div class="line">| 手机        |   <span class="variable">$12</span>   |   <span class="number">12</span>   |</div><div class="line">| 管线        |    <span class="variable">$1</span>    |  <span class="number">234</span>  |</div></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="12-_代码块">12. 代码块</h3>
<p>支持多种种编程语言的语法高亮的显示，行号显示。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="decorator">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="prompt">... </span>prompt'''</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是_Markdown">什么是 Markdown</h2>
<p>Markdown 是一种方便记忆、书写的纯文本标记语言，我们可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这篇博客。</p>
<p>不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。</p>
<p><strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<p>可以使用Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p>它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
]]>
    
    </summary>
    
      <category term="markdown" scheme="http://zhangyigong.github.com/tags/markdown/"/>
    
      <category term="blog" scheme="http://zhangyigong.github.com/tags/blog/"/>
    
  </entry>
  
</feed>
